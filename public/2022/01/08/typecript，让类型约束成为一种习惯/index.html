<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="typescript 类型编程," />










<meta name="description" content="伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一">
<meta property="og:type" content="article">
<meta property="og:title" content="typecript，让类型约束成为一种习惯">
<meta property="og:url" content="http://example.com/2022/01/08/typecript%EF%BC%8C%E8%AE%A9%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E6%88%90%E4%B8%BA%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF/index.html">
<meta property="og:site_name" content="zmlのblog">
<meta property="og:description" content="伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-08T10:36:31.000Z">
<meta property="article:modified_time" content="2022-03-06T04:55:30.564Z">
<meta property="article:author" content="zml">
<meta property="article:tag" content="typescript 类型编程">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/01/08/typecript，让类型约束成为一种习惯/"/>





  <title>typecript，让类型约束成为一种习惯 | zmlのblog</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zmlのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">welcome to my blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/08/typecript%EF%BC%8C%E8%AE%A9%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E6%88%90%E4%B8%BA%E4%B8%80%E7%A7%8D%E4%B9%A0%E6%83%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zmlのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">typecript，让类型约束成为一种习惯</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-08T18:36:31+08:00">
                2022-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基础知识概述"><a href="#基础知识概述" class="headerlink" title="基础知识概述"></a>基础知识概述</h2><p>伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一。</p>
<p> ts类型并不是只能有类型定义，然后给逻辑代码用这么简单。也并不是说代码懂得了一个any这样的全能类型，然后就到处使用any，只关心逻辑代码这块（能跑就行！！！！）。</p>
<h2>1、是开发和维护过程中的工具</h2>

<p>对于ts类型，他也是有自己的编程逻辑的。对于它，我们可以将它理解成一个我们项目开发与维护的工具，这个取决于我们对这个工具的了解程度和利用的程度，利用的好，它是规范我们的逻辑代码的一大利器，代码中的变量便会在明确的类型指引下快速且高效的开发。</p>
<ul><li><strong>约束某一块代码的具体功能</strong></li></ul>

<p>比如说在一个函数中，我们因为有了一个函数的约束，我们可以很明确的知道这个段逻辑块要完成的是一个什么样的功能，不得不说的是，很多人觉得ts是个累赘，那就是很多人都是先写逻辑，后写类型的，就是一种差不多的想法，代码能跑就行，最后只能写成了anyscript。 比如说：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (<span class="attr">arg</span>: A): <span class="function"><span class="params">B</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们便能知道这个函数是一个要将A类型的变量处理处理成B类型的函数，这段代码有这样的作用就通过类型就可以显而易见了，当然前提是A和B的类型是明确的，不能写一个any，Object草草了事，当然在返回类型是也要尽量的准确点，比如说，有的时候为了一个求一个逻辑代码写的顺畅，盲目的让类型迎合变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (<span class="attr">a</span>: A): <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (<span class="attr">a</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">object</span> | <span class="built_in">boolean</span>): <span class="function"><span class="params">B</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的做法在ts编程的时候是不可取（不建议）的，其实在纯js中也是不建议这样的，这样失去了逻辑快单一功能的原则，会让后续的对它的维护显得特别的困难，在之后的调试过程中也会显得格外的困难。</p>
<p>可能，我们会真的碰到这个函数逻辑就是要这样的耦合，那么我们不妨试试另一种类型声明的方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> foo &#123;(<span class="attr">a</span>: A, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">void</span>&#125; <span class="comment">// 参数a为类型A时，那么b的类型为string</span></span><br><span class="line"><span class="keyword">interface</span> foo &#123;(<span class="attr">a</span>: B, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">void</span>&#125; <span class="comment">// 参数a为类型B时，那么b的类型为number</span></span><br><span class="line"><span class="keyword">interface</span> foo &#123;(<span class="attr">a</span>: C, <span class="attr">b</span>: <span class="built_in">number</span>): D&#125; <span class="comment">// 参数a为类型C时，那么b的类型为number，且函数会有返回值D。</span></span><br></pre></td></tr></table></figure>

<p>这三个都是给一个函数声明类型，然后可以很有效的做到逻辑耦合但是类型不耦合，同时也对函数的调用起到了类型校验的作用，不再是像以前写着一个联合类型，让人调用函数的时候觉得这个类型有点傻乎乎的样子，什么也不懂。</p>
<p>这样的方式可以在很大的程度上，让函数的调用变得轻松，不至于让写出的东西让别人无法调用或者类型靠as去断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;<span class="comment">// 参数a为类型string时，那么b的类型为string</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;(<span class="attr">a</span>: <span class="built_in">boolean</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">void</span>&#125; <span class="comment">// 参数a为类型boolean时，那么b的类型为number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">Foo</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span> | <span class="built_in">boolean</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>); <span class="comment">// error,a为string类型时，b参数的类型为string</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">false</span>, <span class="number">2</span>); <span class="comment">// ok👌</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">true</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment">// error,第一个参数为boolean时，第二个参数必须为数字</span></span><br></pre></td></tr></table></figure>

<h6 id="注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别"><a href="#注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别" class="headerlink" title="注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别"></a>注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别</h6><p> 对于函数的逻辑块的类型声明可以这样，同理，组件中我们也可以做到。 其实组件中特别是想要复用性高一点的组件，一般都不会太建议太高的耦合度了，但是，方法也是有的了。</p>
<p>在react中，如果是函数式组件，我们可以跟上面说的函数定义一样的去做</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="variable constant_">A1</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="variable constant_">B1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IProps</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="variable constant_">A2</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="variable constant_">B2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentA</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">IProps</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>同样，这样的耦合度对于这个组件的编写还是不太好的，但是很大程度上可以简化组件的调用，让别人可以更好的去调用它。 在class组件中，这样的做法会显得更加简便</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentA</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;....&#125;</span><br><span class="line">    <span class="title function_">func</span>(): A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentA</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentA</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;.....&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (....)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子对组件的编写过程起到的作用还是比较小的，但是对于组件的调用却有很大的意义，它可以查出组件错误的调用方式。</p>
<ul><li><strong>约束静态数据</strong></li></ul>

<p>作为工具，说白了就是没有它也一样，照样可以做出我想要的东西。但是ts能够一直发展过来，能够受到这么多的前端开发者的青睐自有它的原因。它确实是可以很好的去约束我们的代码，约束我们开发过程中所制造出的各种数据，这个也是取决于，自己对ts的理解程度的。 比如说我们在定义如下数据的类型时</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = &#123;</span><br><span class="line">  <span class="string">&#x27;00:00&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;00:30&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;01:00&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="comment">// ..... 省略，每隔30一个</span></span><br><span class="line">  <span class="string">&#x27;12:00&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;12:30&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;13:00&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;13:30&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;22:30&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;23:00&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;23:30&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在只知道interface，type的时候会一项一项的列出来</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ISchedule</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;00:00&#x27;</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="string">&#x27;00:30&#x27;</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="string">&#x27;01:00&#x27;</span>: <span class="built_in">number</span>,</span><br><span class="line">   <span class="comment">// ..... 省略，每隔30一个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后再深入，知道了[in]，然后又会觉得，类型不过如此，会直接在写出</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ISchedule</span> = &#123;</span><br><span class="line">    [k <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，更加深入的去知道了自带的工具类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ISchedule</span> = &#123;</span><br><span class="line">    [k <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，对ts的使用程度就可以体现出来了，写法的不同，ts发挥的作用也都是不同的。</p>
<p> 后面两种的写法很明显只是为了规避eslint的报错而写的类型的，定义太宽泛，这个时候如果是前端自己写类型定义可以使用类型的模板字符串</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> N = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">0</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Time</span>&lt;T <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>&gt; = T <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;N&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">CheckEnum</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Record</span>&lt;<span class="string">`<span class="subst">$&#123;Time&lt;<span class="number">0</span> | <span class="number">1</span>&gt; | Time&lt;<span class="number">2</span>&gt;&#125;</span>:<span class="subst">$&#123;<span class="string">&#x27;00&#x27;</span> | <span class="string">&#x27;30&#x27;</span>&#125;</span>`</span>, <span class="title class_">CheckEnum</span>&gt;</span><br></pre></td></tr></table></figure>

<p>模板字符串，它集成了[in]语法糖，让所有的可能类型自由组合，可以自动对所有的情况做一次遍历。 当然这样写只是为了提示一下ts的新特性中还有类型模板字符串，但是也可以看得出，ts的类型也越来越完善，可以让类型定义的越来越精确。有了这个模板字符串，很多的以前我们就写一个string的类型，我们都可以给定一个更加精确的定义，来保证我们的类型的准确性 比如说，我们给request定义url的时候我们就可以不写string，完全可以定义一个独有的IUrl类型，来规范url的编写。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IUrl</span> = <span class="string">`/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">export</span> request = &lt;R&gt;<span class="function">(<span class="params">url: IUrl, options</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以避免犯前面忘了加 &#x2F; 这样的低级错误。 此外，类型模版字符串甚至可以用于校验电话号码，时间格式等字符串类型的数据，预防静态数据认为输入是校验太少而出现的错误。</p>
<ul><li><strong>类型的断言</strong></li></ul>

<p>其实ts作为工具，它和eslint的功能差不多，都是一个规范代码书写，可快发提效的手段。同时也会遇到一些ts无法准确做出判断的时候，毕竟ts是不参与逻辑代码的计算的，应该说，是不支持解耦之后的代码的类型运算。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo1</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo2</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">arg: Foo1 | Foo2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (arg.<span class="property">type</span> === <span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// arg is Foo1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arg.<span class="property">type</span> === <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// arg is F002</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种前后耦合的情况下类型还是可以会能有自己的推导的，具体的，可以去看类型的合成与拆分，这也是在某个函数一定要耦合的时候建议的做法。</p>
<h6 id="好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动"><a href="#好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动" class="headerlink" title="好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动"></a>好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Dialog</span> visible=&#123;!!data&#125; close=&#123;data.<span class="property">close</span>&#125;&gt; <span class="comment">// error, data可能为undefined</span></span><br><span class="line"> <span class="comment">// some thing</span></span><br><span class="line">&lt;/<span class="title class_">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这种情况下就难免会给data定义undefined的联合类型的了，到了一些方法中，这个主要是因为数据与视图解耦了，ts就会提醒你某个参数有可能为undefined，但是为undefined的时候数据都是不执行的，其实前面做一个非空检验也没什么大不了的，但是这个时候就看的出ts就比较傻了，此时我们的断言就可以用上了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Dialog</span> visible=&#123;!!data&#125; close=&#123;data!.<span class="property">close</span>&#125;&gt; <span class="comment">// ok, 这里可以用一个非空断言</span></span><br><span class="line"> <span class="comment">// some thing</span></span><br><span class="line">&lt;/<span class="title class_">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>

<p>大部分的时候非空断言( ! )，我们基本上就够用了，可以解决大部分类型推导不过来的问题。</p>
<p>但是还有很多时候，ts的使用程度不同的人会出现不一样的情况，有的人对类型的定义严格，有的人定义的宽松，为什么会这样可以看前面的概述。但是问题还是要解决的，我们这个时候如果真的非常肯定不会出问题，那么我们不妨试试as断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo1</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span> ｜ <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo2</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">arg: Foo2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Foo1</span> = &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(a) <span class="comment">// error, Foo1类型不能给Foo2类型！</span></span><br><span class="line"><span class="title function_">foo</span>(a <span class="keyword">as</span> <span class="title class_">Foo2</span>) <span class="comment">//ok，Foo2类型只是比Foo1类型更小，此处的断言可以告诉ts，我比你更清楚这个数据</span></span><br></pre></td></tr></table></figure>

<p>从这个小例子中我们可以看出，断言对很多类型逃避主义的人其实也是一个非常大的福音，类型定义的时候宽泛就好了，衔接不上的时候直接as unknown as …、as any as …。如果有这种的行为，我也只能说，干的漂亮！ts技术又有了一点提升，只要代码能跑，还真让别人挑不出一点ts的毛病。 话说回来，还是好好的重视类型报错、严格的定义类型吧，如果真的是有非要有耦合的情况，可以看看上面本节的第一点说的方法吧。ts要不了多少时间的，真的可以避免错误，还有减少很多找bug的时间。</p>
<ul><li><strong>全局类型声明</strong></li></ul>

<p>应该很多人想过一个问题，为什么我们可以不需要引入，就可以用Record、Omit、Partail这样的工具类型。还有就是，我们自己开发过程中其实也写出了很多的好用的类型，有的是可以完全脱离某个项目，直接到处都可以用的，比如说我们Omit的源码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h6 id="它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit"><a href="#它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit" class="headerlink" title="它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit"></a>它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyOmit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h6 id="这样就可以使得MyOmit更符合我们的需求"><a href="#这样就可以使得MyOmit更符合我们的需求" class="headerlink" title="这样就可以使得MyOmit更符合我们的需求"></a>这样就可以使得MyOmit更符合我们的需求</h6><h6 id="下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？"><a href="#下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？" class="headerlink" title="下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？"></a>下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？</h6><h6 id="其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了"><a href="#其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了" class="headerlink" title="其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了"></a>其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">MyOmit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>这样就好了，就可以在整个项目中使用了。</p>
<p>如果你以为这一点就这么完了，那你想的肯定是太简单了，另外拓展一下，其实类型也是可以改写的😂😂。</p>
<p>比如说，在使用Object.entries的时候，通过lib.es2017.d.ts中的源码可以看到，entries的类型定义还是有点不太好，不太适合日常的ts类型开发。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of key/values of the enumerable properties of an object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">entries&lt;T&gt;(<span class="attr">o</span>: &#123; [<span class="attr">s</span>: <span class="built_in">string</span>]: T &#125; | <span class="title class_">ArrayLike</span>&lt;T&gt;): [<span class="built_in">string</span>, T][];</span><br></pre></td></tr></table></figure>

<p>这个时候，我们就可以考虑一下改写它的类型，当然不是去修改编辑器的代码，别想太多。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">ObjectConstructor</span> &#123;</span><br><span class="line">  entries&lt;T&gt;(<span class="attr">obj</span>: T): [keyof T, T[keyof T]][];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2>2、是一个具有编程思想的语言</h2>

<h6 id="上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利"><a href="#上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利" class="headerlink" title="上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利"></a>上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利</h6><ul><li><strong>interface、type、class的区别</strong></li></ul>

<h6 id="很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别"><a href="#很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别" class="headerlink" title="很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别"></a>很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别</h6><h6 id="1、type，class定义的类型不可以重复，interface定义的类型可以重复"><a href="#1、type，class定义的类型不可以重复，interface定义的类型可以重复" class="headerlink" title="1、type，class定义的类型不可以重复，interface定义的类型可以重复"></a>1、type，class定义的类型不可以重复，interface定义的类型可以重复</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span> = &#123;...&#125; <span class="comment">// error, Record已经被定义过</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectConstructor</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125; <span class="comment">// ok👌，interface 定义的类型可以重复定义，重新给Object的一些原型方法写类型</span></span><br></pre></td></tr></table></figure>

<h6 id="这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以"><a href="#这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以" class="headerlink" title="这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以"></a>这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="string">&quot;小王&quot;</span> | <span class="string">&quot;小文&quot;</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> <span class="title class_">Keys</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">test</span>: X = &#123;</span><br><span class="line">    <span class="string">&#x27;小王&#x27;</span>: <span class="string">&#x27;肌肉男&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;小文&#x27;</span>: <span class="string">&#x27;也是肌肉男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> XX &#123;</span><br><span class="line">    [k <span class="keyword">in</span> keys]: <span class="built_in">string</span> <span class="comment">// error!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型"><a href="#3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型" class="headerlink" title="3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型"></a>3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animals1</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animals2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animals1</span>, <span class="title class_">Animals2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = <span class="title class_">Animals1</span> &amp; <span class="title class_">Animals2</span> &amp; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4、interface定义的类型可以被改写，type、class定义的类型不可以被改写"><a href="#4、interface定义的类型可以被改写，type、class定义的类型不可以被改写" class="headerlink" title="4、interface定义的类型可以被改写，type、class定义的类型不可以被改写"></a>4、interface定义的类型可以被改写，type、class定义的类型不可以被改写</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">aa</span>: <span class="built_in">string</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;aa: string, ...&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.d.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Foo</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">aa</span>: <span class="built_in">number</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;aa: number; ...&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以"><a href="#5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以" class="headerlink" title="5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以"></a>5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="keyword">typeof</span> foo <span class="comment">//&#123; a: string, b: 2, c: boolean &#125;</span></span><br></pre></td></tr></table></figure>

<p>从以上的几点区别可以看出，类型的定义上，interface和class更像是给ecmascript增加了接口的概念，让类型与代码可以耦合，真正的将js变成了强类型语言（当然总是联合类型就另说了，基本上不会在意这么多了，基本上就不会管类型声明上的区别了）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal1</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal2</span> &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Animal1</span>, <span class="title class_">Animal2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// interface 可以使用extends集成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Animal1</span>, <span class="title class_">Animal2</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 也可以使用class的extends和implements进行继承</span></span><br></pre></td></tr></table></figure>

<h6 id="可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作"><a href="#可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作" class="headerlink" title="可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作"></a>可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultData = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDefaultData</span> = <span class="keyword">typeof</span> defaultData <span class="comment">// &#123;name: string; age: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Ikeys</span> = keyof defaultData</span><br></pre></td></tr></table></figure>

<h6 id="同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算"><a href="#同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算" class="headerlink" title="同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算"></a>同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultData = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDefaultData</span> = <span class="keyword">typeof</span> defaultData <span class="comment">// &#123;name: string; age: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Ikeys</span> = keyof defaultData</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IData</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="keyword">typeof</span> defaultData&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IList</span>  = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Pick</span>&lt;<span class="title class_">IDefaultData</span>, <span class="string">&#x27;name&#x27;</span>&gt; &amp; &#123;<span class="attr">sex</span>: <span class="built_in">number</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">a</span>: infer U; <span class="attr">b</span>: infer U &#125; ? U : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Foo</span>&lt;&#123;<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span>&#125;&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Foo</span>&lt;&#123;<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>&#125;&gt; <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Foo</span>&lt;&#123;<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="built_in">string</span>, <span class="attr">b</span>: symbol&#125;&gt; <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<ul><li><strong>类型的推导</strong></li></ul>

<h6 id="类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型"><a href="#类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型" class="headerlink" title="类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型"></a>类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo1</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="variable constant_">A1</span> <span class="comment">//就当它是A1类型吧</span></span><br><span class="line">    <span class="attr">b</span>: <span class="variable constant_">B1</span> <span class="comment">// 就当它是B1类型吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo2</span> = <span class="title class_">Record</span>&lt;keyof <span class="title class_">Foo1</span>, <span class="title class_">Foo</span>&gt;</span><br></pre></td></tr></table></figure>

<h6 id="而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型"><a href="#而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型" class="headerlink" title="而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型"></a>而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the parameters of a constructor function type in a tuple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<ul><li><strong>类型的条件语句</strong></li></ul>

<h6 id="这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推"><a href="#这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推" class="headerlink" title="这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推"></a>这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// ok👌， arg 受Lengthwise约束，因此lenght是有的</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>&lt;T <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span>&gt; = T <span class="keyword">extends</span> <span class="number">0</span> | <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;N&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// 也可以通过extends的约束功能给类型做一个三元表达的条件语句运算`</span></span><br></pre></td></tr></table></figure>

<ul><li><strong>类型的循环遍历</strong></li></ul>

<p>既然是可以编程的，那就不可以缺少循环遍历的语句了。ts的类型也是可以通过[in]对类型进行循环遍历的。同样的，这只能在type中使用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">d</span>: symbol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">    [k <span class="keyword">in</span> keyof <span class="title class_">Foo</span>]: B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: B; b: B; c: B; d: B&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    [k <span class="keyword">in</span> keyof <span class="title class_">Foo</span>]: B;</span><br><span class="line">&#125; <span class="comment">// error,别问为什么不可以，语言就是这样</span></span><br></pre></td></tr></table></figure>

<h6 id="甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型"><a href="#甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型" class="headerlink" title="甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型"></a>甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">c</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">d</span>: symbol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">    [ <span class="string">`get<span class="subst">$&#123;k&#125;</span>`</span> <span class="keyword">in</span> keyof <span class="title class_">Foo</span>]: B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;geta: B; getb: B; getc: B; getd: B&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="同样，作为"><a href="#同样，作为" class="headerlink" title="同样，作为"></a>同样，作为</h6><ul><li><strong>静态数据的类型</strong></li></ul>

<h6 id="说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时"><a href="#说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时" class="headerlink" title="说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时"></a>说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>  = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样"><a href="#这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样" class="headerlink" title="这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样"></a>这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(status === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode === <span class="string">&#x27;xxx&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试"><a href="#这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试" class="headerlink" title="这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试"></a>这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(status === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode === <span class="string">&#x27;xxx&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了"><a href="#如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了" class="headerlink" title="如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了"></a>如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">IStatus</span> &#123;</span><br><span class="line">    off,</span><br><span class="line">    on</span><br><span class="line">&#125; <span class="comment">// &#123;off: 0, on: 1&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>  = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="title class_">Istatus</span>;</span><br><span class="line">&#125;<span class="comment">// 在之后的过程中都可以使用这个IStatus枚举</span></span><br></pre></td></tr></table></figure>

<h6 id="通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const"><a href="#通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const" class="headerlink" title="通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const"></a>通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cosnt arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="keyword">typeof</span> arr <span class="comment">// string[]</span></span><br><span class="line"><span class="comment">// 这个时候ts的反推类型就是string[]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cosnt arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="keyword">typeof</span> arr <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment">// 这个时候ts的反推类型就是只读熟悉了，它可以用来弥补readonly的一些缺陷</span></span><br></pre></td></tr></table></figure>

<ul><li><strong>动态类型的定义</strong></li></ul>

<h6 id="是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块"><a href="#是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块" class="headerlink" title="是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块"></a>是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &lt;T <span class="keyword">extends</span> &#123;<span class="attr">type</span>: <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>, <span class="attr">val</span>: <span class="built_in">any</span>&#125;&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (arg.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg.<span class="property">val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="attr">a</span>: T</span><br><span class="line">    <span class="attr">b</span>: U</span><br><span class="line">    <span class="attr">foo</span>: <span class="function">(<span class="params">a: T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起"><a href="#类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起" class="headerlink" title="类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起"></a>类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起</h6><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">ProSchema</span>&lt;T = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, unknown&gt;, <span class="title class_">Extra</span> = unknown, V = <span class="title class_">ProSchemaComponentTypes</span>, <span class="title class_">ValueType</span> = <span class="string">&#x27;text&#x27;</span>&gt; = &#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@name</span> 确定这个列的唯一值 */</span></span><br><span class="line">    key?: <span class="title class_">React</span>.<span class="property">ReactText</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持一个数字，[a,b] 会转化为 obj.a.b</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@name</span> 与实体映射的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dataIndex?: keyof T;</span><br><span class="line"></span><br><span class="line">    render?: <span class="function">(<span class="params">dom: React.ReactNode, entity: T, index: <span class="built_in">number</span>, action: ProCoreActionType, schema: ProSchema&lt;T, Extra&gt; &amp; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        isEditable?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">type</span>: V;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span>) =&gt;</span> <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用"><a href="#处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用" class="headerlink" title="处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用"></a>处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用</h6>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/typescript-%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/" rel="tag"># typescript 类型编程</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0"><span class="nav-text">基础知识概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">1、是开发和维护过程中的工具</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%EF%BC%9A%E8%BF%99%E6%A0%B7%E5%A3%B0%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E7%94%A8interface%EF%BC%8C%E5%8E%9F%E5%9B%A0%E5%8F%AF%E4%BB%A5%E8%A7%81%E4%B8%8B%E6%96%87%E7%9A%84interface%E3%80%81type%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A5%BD%E4%BA%86%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%BF%98%E6%98%AF%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%8C%E6%83%B3%E6%8F%90%E9%86%92%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%81%94%E5%90%88%E9%83%BD%E8%BF%98%E6%90%9E%E4%B8%8D%E6%B8%85%E6%A5%9A%E3%80%82%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AF%B4%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E4%BA%9Bdialog%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E6%97%B6%E5%80%99%E4%BC%9A%E4%B9%A0%E6%83%AF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9D%A5%E9%A9%B1%E5%8A%A8%E5%BC%B9%E7%AA%97%E7%9A%84%E6%98%BE%E9%9A%90%E3%80%82%E8%AE%A9%E5%BC%B9%E7%AA%97%E7%9A%84%E6%98%BE%E9%9A%90%E9%80%9A%E8%BF%87%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="nav-text">好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%83%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8F%97%E7%9A%84%E6%98%AFany%E7%BA%A6%E6%9D%9F%EF%BC%8C%E8%99%BD%E7%84%B6%E4%B9%9F%E6%9C%89%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%AC%E5%AE%8C%E5%85%A8%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%86%8D%E5%86%99%E4%B8%80%E4%B8%AAMyOmit"><span class="nav-text">它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E5%BE%97MyOmit%E6%9B%B4%E7%AC%A6%E5%90%88%E6%88%91%E4%BB%AC%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-text">这样就可以使得MyOmit更符合我们的需求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%8F%AA%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%88%AB%E7%9A%84%E5%9C%B0%E6%96%B9%E6%83%B3%E4%BD%BF%E7%94%A8%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%BE%97%E8%A6%81%E5%8E%BBimport%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%98%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E7%A8%8D%E5%BE%AE%E7%94%A8%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%89%93%E5%8C%85%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E6%98%AF%E5%8E%BB%E6%8E%89%E7%9A%84%E3%80%82%E9%82%A3%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%88%AB%E7%9A%84%E5%9C%B0%E6%96%B9%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%B0%B1%E5%A5%BD%E4%BA%86%EF%BC%9F%EF%BC%9F"><span class="nav-text">下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B6%E5%AE%9E%E8%BF%99%E4%B8%AA%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-d-ts%EF%BC%8C%E6%96%87%E4%BB%B6%E5%B0%B1%E5%A5%BD%E4%BA%86"><span class="nav-text">其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text">2、是一个具有编程思想的语言</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8A%E4%B8%80%E8%8A%82%E4%B8%AD%E6%88%91%E4%BB%AC%E4%BB%8Etypescript%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A7%84%E8%8C%83%E5%BC%80%E5%8F%91%E7%9A%84%E5%B7%A5%E5%85%B7%E5%85%A5%E6%89%8B%EF%BC%8C%E8%AE%B2%E8%BF%B0%E4%BA%86ts%E5%8F%AF%E4%BB%A5%E6%9C%89%E7%9A%84%E5%87%A0%E5%A4%A7%E5%8A%9F%E8%83%BD%E3%80%82%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%80%E8%8A%82%EF%BC%8C%E5%B0%B1%E8%AE%B2%E8%BF%B0%E4%B8%80%E4%B8%8Btypescript%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%9A%84%E3%80%82%E5%AE%83%E4%B9%9F%E6%98%AF%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E3%80%81%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%EF%BC%8C%E5%BD%93%E4%BD%A0%E4%B9%A0%E6%83%AF%E4%BA%86%E8%BF%99%E4%B8%AA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%A4%9F%E6%9B%B4%E5%8A%A0%E6%B7%B1%E5%88%BB%E7%9A%84%E6%84%9F%E5%8F%97%E5%88%B0ts%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BE%BF%E5%88%A9"><span class="nav-text">上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%88%E5%A4%9A%E4%BA%BA%E5%AF%B9interface%E3%80%81type%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%85%E4%BB%85%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82-%E4%BD%86%E6%98%AF%E4%BA%8B%E5%AE%9E%E4%B8%8A%EF%BC%8C%E5%AE%83%E5%B0%B1%E6%98%AF%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%88%AB%E3%80%82-%E5%8F%AA%E4%B8%8D%E8%BF%87%EF%BC%8C%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1%E3%80%81type%EF%BC%8Cclass%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%EF%BC%8Cinterface%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D"><span class="nav-text">1、type，class定义的类型不可以重复，interface定义的类型可以重复</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%99%E5%B0%B1%E6%98%AF%E5%9C%A8%E4%B8%8A%E8%8A%82%E4%B8%AD%E6%89%80%E8%AE%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%82-2%E3%80%81type%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-in-%EF%BC%8Cinterface%EF%BC%8Cclass%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5"><span class="nav-text">这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3%E3%80%81interface%EF%BC%8Cclass%E4%BD%BF%E7%94%A8extends%E3%80%81implements%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%8Ctype%E5%88%99%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-amp-%E7%AC%A6%E5%8F%B7%E7%BB%84%E5%90%88%E3%80%81%E5%90%88%E5%B9%B6%E7%B1%BB%E5%9E%8B"><span class="nav-text">3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E3%80%81interface%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%94%B9%E5%86%99%EF%BC%8Ctype%E3%80%81class%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%94%B9%E5%86%99"><span class="nav-text">4、interface定义的类型可以被改写，type、class定义的类型不可以被改写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5%E3%80%81type%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8typeof%E3%80%81keyof%E3%80%81infer%E5%8E%BB%E5%8F%8D%E6%8E%A8%E7%B1%BB%E5%9E%8B%EF%BC%8Cinterface%E3%80%81class%E4%B8%8D%E5%8F%AF%E4%BB%A5"><span class="nav-text">5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%98%E6%98%AFjava%E9%87%8C%E9%9D%A2%E7%9A%84%E9%82%A3%E4%B8%80%E5%A5%97%E3%80%82-%E4%B9%8B%E5%90%8E%E7%9A%84type%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BE%BF%E5%8F%88%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%BA%86%EF%BC%8C%E5%AE%83%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E6%83%B3%E4%BA%86%E3%80%82%E5%AE%83%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8typeof%EF%BC%8Ckeyof%EF%BC%8Cinfer%E7%AD%89%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E3%80%82%E5%90%8C%E6%97%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-in-%E7%AD%89%E5%AF%B9%E7%B1%BB%E5%9E%8B%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E6%8E%A8%E5%AF%BC%E6%93%8D%E4%BD%9C"><span class="nav-text">可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%9C%89%E4%BA%86%E9%80%9A%E8%BF%87%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%9C%89%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B9%9F%E6%9C%89%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84-%EF%BC%89%EF%BC%8C%E5%AF%B9%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%90%84%E7%A7%8D%E8%BF%90%E7%AE%97"><span class="nav-text">同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A8%E5%AF%BC%E9%82%A3%E5%B0%B1%E6%98%AF%E6%AF%94%E8%BE%83%E8%80%83%E9%AA%8C%E5%AF%B9%E7%B1%BB%E5%9E%8B%E5%A4%9F%E4%B8%8D%E5%A4%9F%E7%90%86%E8%A7%A3%E4%BA%86%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84ts%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%B1%E4%B8%BAtypeof%E3%80%81keyof%E3%80%81infer%E3%80%82-%E4%B8%8D%E8%BF%87%E5%80%BC%E5%BE%97%E8%AF%B4%E7%9A%84%E5%B0%B1%E6%98%AFinfer%E5%AF%B9%E4%BA%8E%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E8%BF%98%E6%98%AF%E6%B2%A1%E9%82%A3%E4%B9%88%E5%A4%9A%E7%9A%84%E3%80%82%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%9A%E7%9A%84%E8%BF%98%E6%98%AFtypeof%E5%92%8Ckeyof%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BA%BA%E6%9B%B4%E5%BF%AB%E9%80%9F%E7%9A%84%E5%8E%BB%E5%BE%97%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%80%8C%E5%AF%B9%E4%BA%8Einfer%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BE%88%E5%A4%9A%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%AE%83%E6%9D%A5%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83Parammeters%E3%80%81ReturnType%E7%AD%89%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="nav-text">而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Eextends%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%EF%BC%8Cextends%E5%AE%83%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E5%9C%A8interface%E4%B8%8A%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF-%E6%88%96%E8%AE%B8%E6%9C%89%E7%9A%84%E4%BA%BA%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%85%E9%99%90%E4%BA%8E%E6%AD%A4-%E3%80%82%E5%90%8C%E6%97%B6%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%BE%88%E5%83%8F%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8F%8D%E6%8E%A8"><span class="nav-text">这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%9A%E8%87%B3%E4%B9%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%BF%AB%E9%80%9F%E7%9A%84%E5%86%99%E5%87%BA%E6%9B%B4%E5%8A%A0%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%A0%B7%EF%BC%8C%E4%BD%9C%E4%B8%BA"><span class="nav-text">同样，作为</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B4%E5%88%B0%E8%BF%99%E4%B8%AA%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E4%BA%86%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%99%E4%B8%80%E4%B8%AAstring%EF%BC%8Cnumber%E5%85%B6%E5%AE%9E%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B7%E8%A1%8D-%E6%AF%94%E5%A6%82%E8%AF%B4%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAmode%EF%BC%8C%E6%88%96%E8%80%85status%E6%97%B6"><span class="nav-text">说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%99%E6%A0%B7%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%BE%88%E6%98%8E%E6%98%BE%E4%B9%9F%E6%98%AF%E5%9C%A8%E9%80%83%E9%81%BF%E7%9A%84%EF%BC%8C%E6%AF%95%E7%AB%9F%E5%90%8E%E9%9D%A2%E7%9A%84status%E6%88%96%E8%80%85mode%E4%B9%9F%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF%E8%A6%81%E7%94%A8%E7%9A%84%E3%80%82%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BE%88%E6%9C%89%E5%8F%AF%E8%83%BD%E5%B0%B1%E4%BC%9A%E8%BF%99%E6%A0%B7"><span class="nav-text">这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%99%E6%A0%B7%E5%B0%B1%E6%98%AF%E8%AE%A9%E5%90%8E%E9%9D%A2%E7%9A%84%E7%BB%B4%E6%8A%A4%E8%80%85%E9%A3%8E%E4%B8%AD%E5%87%8C%E4%B9%B1%E4%BA%86%EF%BC%8C%E5%BE%88%E4%B8%8D%E5%88%A9%E4%BA%8E%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%90%8C%E6%97%B6%E9%82%A3%E4%B8%AAnumber%E5%92%8Cstring%E4%B9%9F%E5%BE%88%E5%AE%B9%E6%98%93%E5%86%99%E9%94%99%E3%80%82-%E5%85%B6%E5%AE%9E%E5%AF%B9%E4%BA%8E%E8%BF%99%E7%A7%8D%E9%9D%99%E6%80%81%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%98%AF%E4%B8%8D%E5%BA%94%E8%AF%A5%E7%94%A8%E4%B8%AAnumber%E5%92%8Cstring%E7%9A%84%E3%80%82-%E5%AF%B9%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%87%AA%E4%BA%A7%E8%87%AA%E9%94%80%E7%9A%84mode%E6%88%96%E8%80%85status%EF%BC%8C%E4%B8%8D%E5%A6%A8%E8%AF%95%E8%AF%95"><span class="nav-text">这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E5%AF%B9%E4%BA%8E%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%9A%84%E8%80%8C%E4%B8%94%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E4%BA%86"><span class="nav-text">如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E5%B0%B1%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%86%EF%BC%8C%E5%85%B6%E5%AE%9Eenum%E4%B8%8E%E7%9B%B8%E4%BC%BC%EF%BC%8C%E5%AE%83%E6%97%A2%E5%8F%AF%E4%BB%A5%E5%8F%82%E4%B8%8E%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8F%82%E4%B8%8E%E7%B1%BB%E5%9E%8B%E3%80%82%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%AE%83%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%82%E5%9C%A8%E9%80%BB%E8%BE%91%E4%B8%AD%EF%BC%8C%E5%AE%83%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%85%85%E5%BD%93%E5%87%BA%E4%B8%80%E4%B8%AAconstant%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86-%E5%AF%B9%E4%BA%8E%E9%9D%99%E6%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%B8%80%E7%82%B9%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%EF%BC%8C%E9%82%A3%E5%B0%B1%E6%98%AFas-const"><span class="nav-text">通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%98%AF%E7%BC%96%E7%A8%8B%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E5%BE%97%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%8C%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%8Cts%E4%B8%AD%E4%B9%9F%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%E4%BE%BF%E6%98%AF%E6%B3%9B%E5%9E%8B%E4%BA%86%E3%80%82%E6%9C%89%E4%BA%86%E5%AE%83%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%BC%8F%E7%9A%84%E5%B0%86%E7%B1%BB%E5%9E%8B%E5%B8%A6%E5%85%A5%E4%BA%86%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A1%8C%E5%88%97%E3%80%82-%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%E4%B8%8A%E6%B3%9B%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%B7%9F%E5%87%BD%E6%95%B0%E8%B7%9F%E7%B1%BB%E8%BF%9B%E8%A1%8C%E8%80%A6%E5%90%88%EF%BC%8C%E5%8E%BB%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%8F%AF%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8A%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%86%99%E5%87%BA%E5%90%84%E7%A7%8D%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8F%90%E5%8D%87%E6%88%91%E4%BB%AC%E7%9A%84%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%8B%BF%E6%88%91%E4%BB%AC%E7%86%9F%E7%9F%A5%E7%9A%84protable%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E8%AF%B4%E8%B5%B7"><span class="nav-text">类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%84%E4%BA%8E%E4%B8%80%E4%B8%AAProtable%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E6%88%AA%E5%8F%96%E4%BA%86%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E5%B0%8F%E6%AE%B5%E3%80%82%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E4%BC%9A%E6%8A%8A%E4%BC%A0%E5%85%A5%E7%9A%84%E4%B8%80%E8%A1%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%81%9A%E5%8F%82%E6%95%B0T%E4%BC%A0%E8%BF%9B%E6%9D%A5%EF%BC%8C%E5%9C%A8dataIndex%E5%92%8Crender%E8%BF%99%E9%87%8C%E7%9B%B4%E6%8E%A5%E6%8A%8AT%E5%BD%93%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8"><span class="nav-text">处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zml</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
