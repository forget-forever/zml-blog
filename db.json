{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/49786633.jpeg","path":"images/49786633.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg","path":"images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c49c0d72444adf91572ea361cf805353ffdf7109","modified":1646545344305},{"_id":"source/_posts/你不知道的TypeScript.md","hash":"8c7a1fe51f46e0c295e39348d6a1c7b96edbb61b","modified":1646550985700},{"_id":"source/_posts/typecript，让类型约束成为一种习惯.md","hash":"6f1095308ecbf3be3cff2354ecd1328c57f45d03","modified":1646542530564},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708974},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708960},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708960},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708971},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708971},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708971},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708973},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646484708973},{"_id":"themes/next/.DS_Store","hash":"ae133a21dd657c0151c90a1603cfe98940dc3b60","modified":1646552204010},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1646484708956},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1646484708956},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1646484708956},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1646484708956},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1646484708956},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1646484708956},{"_id":"themes/next/_config.yml","hash":"30a518f948682747db95b7d3814d3808f013a43c","modified":1646552267774},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1646484708957},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1646484708956},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1646484708964},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1646484708957},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1646484708957},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1646484708957},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1646484708957},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1646484708957},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1646484708957},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1646484708957},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1646484708958},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1646484708958},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1646484708958},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1646484708958},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1646484708958},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1646484708958},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1646484708958},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1646484708958},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1646484708958},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1646484708958},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1646484708958},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1646484708958},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1646484708963},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1646484708963},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1646484708963},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1646484708963},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1646484708964},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1646484708958},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1646484708964},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1646484708964},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1646484708964},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1646484708964},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1646484709008},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1646484709008},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1646484708958},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1646484708959},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1646484708958},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1646484709008},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1646484708959},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1646484708959},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1646484708959},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1646484708959},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1646484708959},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1646484708959},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1646484708959},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1646484708959},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1646484708960},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1646484708959},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1646484708959},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1646484708959},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1646484708960},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1646484708960},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1646484708960},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1646484708962},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1646484708962},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1646484708962},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1646484708962},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1646484708962},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1646484708964},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1646484708962},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1646484708965},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1646484708965},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1646484708965},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1646484708965},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1646484708965},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1646484708965},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1646484708965},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1646484708965},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1646484708962},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1646484708974},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1646484708974},{"_id":"themes/next/source/images/49786633.jpeg","hash":"c17a984b88cb2ee77197ce5707ffc007fac8a820","modified":1646552234721},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1646484708974},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1646484708974},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1646484708974},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1646484708974},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1646484708974},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1646484708974},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1646484708974},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1646484708975},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1646484708974},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1646484708975},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1646484708975},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1646484708975},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1646484708975},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1646484708975},{"_id":"themes/next/source/images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg","hash":"d59bb49a4ab059de7d694fa310a6a9705782ed98","modified":1646552187709},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1646484708975},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1646484708975},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1646484708975},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1646484708959},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1646484708959},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1646484708960},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1646484708960},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1646484708960},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1646484708960},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1646484708960},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1646484708960},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1646484708960},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1646484708960},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1646484708960},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1646484708960},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1646484708961},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1646484708961},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1646484708961},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1646484708961},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1646484708962},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1646484708962},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1646484708963},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1646484708963},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1646484708963},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1646484708971},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1646484708971},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1646484708971},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1646484708971},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1646484708973},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1646484708973},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1646484708973},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1646484708973},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1646484708975},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1646484708975},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1646484708975},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1646484708975},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1646484708975},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1646484708980},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1646551818432},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1646484708975},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1646484708976},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1646484708976},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1646484708976},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1646484708976},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1646484708981},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1646484708981},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1646484708982},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1646484708982},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1646484708986},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1646484708986},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1646484708986},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1646484708963},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1646484708986},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1646484708986},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1646484708986},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1646484708986},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1646484708987},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1646484708987},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1646484708996},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1646484708996},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1646484708996},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1646484708996},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1646484708996},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1646484708997},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1646484708997},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1646484708997},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1646484708997},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1646484708997},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1646484708998},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1646484708997},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1646484708997},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1646484708997},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1646484708997},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1646484708997},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1646484708997},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1646484708998},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1646484708998},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1646484709006},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1646484709007},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1646484709008},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1646484708962},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1646484708963},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1646484708965},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1646484709007},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1646484709008},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1646484708965},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1646484708965},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1646484708967},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1646484708970},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1646484708970},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1646484708970},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1646484708970},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1646484708970},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1646484708971},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1646484708971},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1646484708971},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1646484708971},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1646484708969},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1646484708971},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1646484708973},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1646484708973},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1646484708973},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1646484708973},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1646484708973},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1646484708973},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1646484708976},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1646484708977},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1646484708982},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1646484708979},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1646484708980},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1646484708984},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1646484708986},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1646484708986},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1646484708986},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1646484708987},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1646484708985},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1646484708987},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1646484708987},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1646484709006},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1646484709006},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1646484708966},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1646484708967},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1646484708968},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1646484708969},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1646484708970},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1646484708970},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1646484708972},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1646484708973},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1646484708976},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1646484708977},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1646484708977},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1646484708977},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1646484708977},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1646484708985},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1646484708985},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1646484708996},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1646484708979},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1646484708996},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1646484708993},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1646484708988},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1646484708992},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1646484708989},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1646484709007},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1646484708981},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1646484708991},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1646484709006},{"_id":"public/tags/typescript-类型编程/index.html","hash":"d72891f6dfe7d3460e2924d56d405009578e4678","modified":1646552275400},{"_id":"public/tags/typescript-基础知识/index.html","hash":"23db0855835b60683c3cf74b543565ebac41ec36","modified":1646552275400},{"_id":"public/archives/index.html","hash":"97329dd15fd774f2714806895773712bd5280d09","modified":1646552275400},{"_id":"public/archives/2022/index.html","hash":"13c39a97a27e469dad5bd0aa2571668bb72d9609","modified":1646552275400},{"_id":"public/archives/2022/01/index.html","hash":"7bf26f829483356314d186f1ac01583068414868","modified":1646552275400},{"_id":"public/archives/2022/03/index.html","hash":"1c2954293a98cbdadd0f15bec9f5a976b32795b2","modified":1646552275400},{"_id":"public/index.html","hash":"7ef5d20e3697c493b3d9e829a7a67642d3d9dc1d","modified":1646552275400},{"_id":"public/2022/03/06/你不知道的TypeScript/index.html","hash":"00de795ff29ff24b0d96056ba7ab0f5a7c74ead9","modified":1646552275400},{"_id":"public/2022/01/08/typecript，让类型约束成为一种习惯/index.html","hash":"77628c20edc125d073a79543ee715bd6110028e1","modified":1646552275400},{"_id":"public/images/49786633.jpeg","hash":"c17a984b88cb2ee77197ce5707ffc007fac8a820","modified":1646552275400},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1646552275400},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1646552275400},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1646552275400},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1646552275400},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1646552275400},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1646552275400},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1646552275400},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1646552275400},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1646552275400},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1646552275400},{"_id":"public/images/cropped-cb4366f7c1e651c26dbfb39226e936ec.jpeg","hash":"d59bb49a4ab059de7d694fa310a6a9705782ed98","modified":1646552275400},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1646552275400},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1646552275400},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1646552275400},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1646552275400},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1646552275400},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1646552275400},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1646552275400},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1646552275400},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1646552275400},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1646552275400},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1646552275400},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1646552275400},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1646552275400},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1646552275400},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1646552275400},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1646552275400},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1646552275400},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1646552275400},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1646552275400},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1646552275400},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1646552275400},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1646552275400},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1646552275400},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1646552275400},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1646552275400},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1646552275400},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1646552275400},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1646552275400},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1646552275400},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1646552275400},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1646552275400},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1646552275400},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1646552275400},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1646552275400},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1646552275400},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1646552275400},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1646552275400},{"_id":"public/lib/fastclick/README.html","hash":"1c2cb1168e9df516e311177476e499990453965d","modified":1646552275400},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1646552275400},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1646552275400},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"bc6cf8951a99074bdc6ec9172f03fb7c0e412729","modified":1646552275400},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1646552275400},{"_id":"public/lib/jquery_lazyload/README.html","hash":"96a5c2cc00de5b338ae972c1e8de879d2d919608","modified":1646552275400},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1646552275400},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1646552275400},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1646552275400},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1646552275400},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1646552275400},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1646552275400},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1646552275400},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1646552275400},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1646552275400},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1646552275400},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1646552275400},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1646552275400},{"_id":"public/css/main.css","hash":"3eed550acbcea19a5d947ac0e3331c8f30fd1d93","modified":1646552275400},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1646552275400},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1646552275400},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1646552275400},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1646552275400},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1646552275400},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1646552275400},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1646552275400},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1646552275400},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1646552275400},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1646552275400},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1646552275400},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1646552275400},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1646552275400},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1646552275400},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1646552275400},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1646552275400},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1646552275400},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1646552275400},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1646552275400},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1646552275400},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1646552275400}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"typecript，让类型约束成为一种习惯","date":"2022-01-08T10:36:31.000Z","description":"伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一","_content":"## 基础知识概述\n\n伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一。\n\n ts类型并不是只能有类型定义，然后给逻辑代码用这么简单。也并不是说代码懂得了一个any这样的全能类型，然后就到处使用any，只关心逻辑代码这块（能跑就行！！！！）。\n\n<h2>1、是开发和维护过程中的工具</h2>\n\n对于ts类型，他也是有自己的编程逻辑的。对于它，我们可以将它理解成一个我们项目开发与维护的工具，这个取决于我们对这个工具的了解程度和利用的程度，利用的好，它是规范我们的逻辑代码的一大利器，代码中的变量便会在明确的类型指引下快速且高效的开发。\n\n<ul><li><strong>约束某一块代码的具体功能</strong></li></ul>\n\n比如说在一个函数中，我们因为有了一个函数的约束，我们可以很明确的知道这个段逻辑块要完成的是一个什么样的功能，不得不说的是，很多人觉得ts是个累赘，那就是很多人都是先写逻辑，后写类型的，就是一种差不多的想法，代码能跑就行，最后只能写成了anyscript。 比如说：\n\n```typescript\nconst foo = (arg: A): B => {\n    // do something....\n}\n```\n\n我们便能知道这个函数是一个要将A类型的变量处理处理成B类型的函数，这段代码有这样的作用就通过类型就可以显而易见了，当然前提是A和B的类型是明确的，不能写一个any，Object草草了事，当然在返回类型是也要尽量的准确点，比如说，有的时候为了一个求一个逻辑代码写的顺畅，盲目的让类型迎合变量。\n\n```typescript\nconst foo = (a: A): string | number | boolean => {\n    // do something...\n}\n```\n\n```typescript\nconst foo = (a: string | number | object | boolean): B => {\n    // do something...\n}\n```\n\n这样的做法在ts编程的时候是不可取（不建议）的，其实在纯js中也是不建议这样的，这样失去了逻辑快单一功能的原则，会让后续的对它的维护显得特别的困难，在之后的调试过程中也会显得格外的困难。\n\n可能，我们会真的碰到这个函数逻辑就是要这样的耦合，那么我们不妨试试另一种类型声明的方式。\n\n```typescript\ninterface foo {(a: A, b: string): void} // 参数a为类型A时，那么b的类型为string\ninterface foo {(a: B, b: number): void} // 参数a为类型B时，那么b的类型为number\ninterface foo {(a: C, b: number): D} // 参数a为类型C时，那么b的类型为number，且函数会有返回值D。\n```\n\n这三个都是给一个函数声明类型，然后可以很有效的做到逻辑耦合但是类型不耦合，同时也对函数的调用起到了类型校验的作用，不再是像以前写着一个联合类型，让人调用函数的时候觉得这个类型有点傻乎乎的样子，什么也不懂。\n\n这样的方式可以在很大的程度上，让函数的调用变得轻松，不至于让写出的东西让别人无法调用或者类型靠as去断言。\n\n```typescript\ndeclare interface Foo {\n  (a: string, b: string): void;\n}// 参数a为类型string时，那么b的类型为string\ndeclare interface Foo {(a: boolean, b: number): void} // 参数a为类型boolean时，那么b的类型为number\nconst foo: Foo = (a: string | boolean, b: number | string) => {\n  // do something......\n}\n\nfoo('1', 2); // error,a为string类型时，b参数的类型为string\nfoo(false, 2); // ok👌\nfoo(true, '2') // error,第一个参数为boolean时，第二个参数必须为数字\n```\n\n###### 注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\n\n 对于函数的逻辑块的类型声明可以这样，同理，组件中我们也可以做到。 其实组件中特别是想要复用性高一点的组件，一般都不会太建议太高的耦合度了，但是，方法也是有的了。\n\n在react中，如果是函数式组件，我们可以跟上面说的函数定义一样的去做\n\n```typescript\ninterface IProps {\n    a: A1;\n    b: B1;\n};\ninterface IProps {\n    a: A2;\n    b: B2;\n}\nconst ComponentA: React.FC<IProps>;\n```\n\n同样，这样的耦合度对于这个组件的编写还是不太好的，但是很大程度上可以简化组件的调用，让别人可以更好的去调用它。 在class组件中，这样的做法会显得更加简便\n\n```typescript\ninterface ComponentA {\n    props: {....}\n    func(): A\n}\ninterface ComponentA {\n    props: {....}\n}\nclass ComponentA extends Component {\n    constructor() {\n        this.state = {.....}\n    }\n    render() {\n        return (....)\n    }\n}\n```\n\n这样子对组件的编写过程起到的作用还是比较小的，但是对于组件的调用却有很大的意义，它可以查出组件错误的调用方式。\n\n<ul><li><strong>约束静态数据</strong></li></ul>\n\n作为工具，说白了就是没有它也一样，照样可以做出我想要的东西。但是ts能够一直发展过来，能够受到这么多的前端开发者的青睐自有它的原因。它确实是可以很好的去约束我们的代码，约束我们开发过程中所制造出的各种数据，这个也是取决于，自己对ts的理解程度的。 比如说我们在定义如下数据的类型时\n\n```typescript\nconst schedule = {\n  '00:00': 0,\n  '00:30': 0,\n  '01:00': 0,\n   // ..... 省略，每隔30一个\n  '12:00': 0,\n  '12:30': 1,\n  '13:00': 1,\n  '13:30': 1,\n  '22:30': 0,\n  '23:00': 0,\n  '23:30': 0,\n};\n```\n\n在只知道interface，type的时候会一项一项的列出来\n\n```typescript\ntype ISchedule = {\n  '00:00': number,\n  '00:30': number,\n  '01:00': number,\n   // ..... 省略，每隔30一个\n};\n```\n\n然后再深入，知道了[in]，然后又会觉得，类型不过如此，会直接在写出\n\n```typescript\ntype ISchedule = {\n    [k in string]: number\n}\n```\n\n之后，更加深入的去知道了自带的工具类型\n\n```typescript\ntype ISchedule = {\n    [k in string]: number\n}\n```\n\n很明显，对ts的使用程度就可以体现出来了，写法的不同，ts发挥的作用也都是不同的。\n\n 后面两种的写法很明显只是为了规避eslint的报错而写的类型的，定义太宽泛，这个时候如果是前端自己写类型定义可以使用类型的模板字符串\n\n```typescript\ntype N = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0\ntype Time<T extends 0 | 1 | 2> = T extends 0 | 1 ? `${T}${N}` : `${T}${0|1|2|3}`\nenum CheckEnum {}\ntype A = Record<`${Time<0 | 1> | Time<2>}:${'00' | '30'}`, CheckEnum>\n```\n\n模板字符串，它集成了[in]语法糖，让所有的可能类型自由组合，可以自动对所有的情况做一次遍历。 当然这样写只是为了提示一下ts的新特性中还有类型模板字符串，但是也可以看得出，ts的类型也越来越完善，可以让类型定义的越来越精确。有了这个模板字符串，很多的以前我们就写一个string的类型，我们都可以给定一个更加精确的定义，来保证我们的类型的准确性 比如说，我们给request定义url的时候我们就可以不写string，完全可以定义一个独有的IUrl类型，来规范url的编写。\n\n```typescript\ntype IUrl = `/${string}`\nexport request = <R>(url: IUrl, options) => Promise<T>\n```\n\n这样就可以避免犯前面忘了加 / 这样的低级错误。 此外，类型模版字符串甚至可以用于校验电话号码，时间格式等字符串类型的数据，预防静态数据认为输入是校验太少而出现的错误。\n\n<ul><li><strong>类型的断言</strong></li></ul>\n\n其实ts作为工具，它和eslint的功能差不多，都是一个规范代码书写，可快发提效的手段。同时也会遇到一些ts无法准确做出判断的时候，毕竟ts是不参与逻辑代码的计算的，应该说，是不支持解耦之后的代码的类型运算。\n\n```typescript\ntype Foo1 = {\n  value: number,\n  type: 'a'\n}\ntype Foo2 = {\n  value: string,\n  type: 'b'\n}\nconst foo = (arg: Foo1 | Foo2) => {\n  if (arg.type === 'a'){\n    // arg is Foo1\n    console.log(arg)\n  }\n  if (arg.type === 'b') {\n    // arg is F002\n    console.log(arg)\n  }\n}\n```\n\n在这种前后耦合的情况下类型还是可以会能有自己的推导的，具体的，可以去看类型的合成与拆分，这也是在某个函数一定要耦合的时候建议的做法。\n\n###### 好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\n\n```typescript\n<Dialog visible={!!data} close={data.close}> // error, data可能为undefined\n // some thing\n</Dialog>\n```\n\n这种情况下就难免会给data定义undefined的联合类型的了，到了一些方法中，这个主要是因为数据与视图解耦了，ts就会提醒你某个参数有可能为undefined，但是为undefined的时候数据都是不执行的，其实前面做一个非空检验也没什么大不了的，但是这个时候就看的出ts就比较傻了，此时我们的断言就可以用上了\n\n```typescript\n<Dialog visible={!!data} close={data!.close}> // ok, 这里可以用一个非空断言\n // some thing\n</Dialog>\n```\n\n大部分的时候非空断言( ! )，我们基本上就够用了，可以解决大部分类型推导不过来的问题。\n\n但是还有很多时候，ts的使用程度不同的人会出现不一样的情况，有的人对类型的定义严格，有的人定义的宽松，为什么会这样可以看前面的概述。但是问题还是要解决的，我们这个时候如果真的非常肯定不会出问题，那么我们不妨试试as断言。\n\n```typescript\ntype Foo1 = {\n  value: number ｜ string,\n  type: string\n}\ntype Foo2 = {\n  value: string,\n  type: 'b'\n}\nconst foo = (arg: Foo2) => {\n  // do something\n}\nconst a: Foo1 = {\n    .....\n}\nfoo(a) // error, Foo1类型不能给Foo2类型！\nfoo(a as Foo2) //ok，Foo2类型只是比Foo1类型更小，此处的断言可以告诉ts，我比你更清楚这个数据\n```\n\n从这个小例子中我们可以看出，断言对很多类型逃避主义的人其实也是一个非常大的福音，类型定义的时候宽泛就好了，衔接不上的时候直接as unknown as ...、as any as ...。如果有这种的行为，我也只能说，干的漂亮！ts技术又有了一点提升，只要代码能跑，还真让别人挑不出一点ts的毛病。 话说回来，还是好好的重视类型报错、严格的定义类型吧，如果真的是有非要有耦合的情况，可以看看上面本节的第一点说的方法吧。ts要不了多少时间的，真的可以避免错误，还有减少很多找bug的时间。\n\n<ul><li><strong>全局类型声明</strong></li></ul>\n\n应该很多人想过一个问题，为什么我们可以不需要引入，就可以用Record、Omit、Partail这样的工具类型。还有就是，我们自己开发过程中其实也写出了很多的好用的类型，有的是可以完全脱离某个项目，直接到处都可以用的，比如说我们Omit的源码。\n\n```typescript\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\n###### 它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\n\n```typescript\ntype MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n```\n\n###### 这样就可以使得MyOmit更符合我们的需求\n\n###### 下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\n\n###### 其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了\n\n```typescript\n// public.d.ts\ndeclare type MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n```\n\n这样就好了，就可以在整个项目中使用了。\n\n如果你以为这一点就这么完了，那你想的肯定是太简单了，另外拓展一下，其实类型也是可以改写的😂😂。\n\n比如说，在使用Object.entries的时候，通过lib.es2017.d.ts中的源码可以看到，entries的类型定义还是有点不太好，不太适合日常的ts类型开发。\n\n```typescript\n     /**\n         * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries<T>(o: { [s: string]: T } | ArrayLike<T>): [string, T][];\n```\n\n这个时候，我们就可以考虑一下改写它的类型，当然不是去修改编辑器的代码，别想太多。\n\n```typescript\n// .d.ts\ndeclare interface ObjectConstructor {\n  entries<T>(obj: T): [keyof T, T[keyof T]][];\n}\n```\n\n<h2>2、是一个具有编程思想的语言</h2>\n\n###### 上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\n\n<ul><li><strong>interface、type、class的区别</strong></li></ul>\n\n###### 很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别\n\n###### 1、type，class定义的类型不可以重复，interface定义的类型可以重复\n\n```typescript\ntype Record = {...} // error, Record已经被定义过\ninterface ObjectConstructor {\n    ......\n} // ok👌，interface 定义的类型可以重复定义，重新给Object的一些原型方法写类型\n```\n\n###### 这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以\n\n```typescript\ntype Keys = \"小王\" | \"小文\"\ntype X = {\n  [key in Keys]: string\n}\nconst test: X = {\n    '小王': '肌肉男',\n    '小文': '也是肌肉男'\n}\n\ninterface XX {\n    [k in keys]: string // error!!!\n}\n```\n\n###### 3、interface，class使用extends、implements组合类型，type则可以通过&, |符号组合、合并类型\n\n```typescript\ninterface Animals1 {\n    ...\n}\ninterface Animals2 {\n    ...\n}\ninterface Cat extends Animals1, Animals2 {\n    ...\n}\n\ntype Dog = Animals1 & Animals2 & {\n    ...\n}\n```\n\n###### 4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\n\n```typescript\n// a.d.ts\nexport interface Foo {\n    aa: string;\n    ....\n}\n// {aa: string, ...}\n```\n\n```typescript\n// b.d.ts\nimport type { Foo } from 'a'\ninterface Foo {\n    aa: number;\n    ...\n}\n// {aa: number; ...}\n```\n\n###### 5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\n\n```typescript\nconst foo = {\n    a: 'a',\n    b: 2,\n    c: true\n}\ntype Foo = typeof foo //{ a: string, b: 2, c: boolean }\n```\n\n从以上的几点区别可以看出，类型的定义上，interface和class更像是给ecmascript增加了接口的概念，让类型与代码可以耦合，真正的将js变成了强类型语言（当然总是联合类型就另说了，基本上不会在意这么多了，基本上就不会管类型声明上的区别了）。\n\n```typescript\ninterface Animal1 {\n    a: string;\n}\ninterface Animal2 {\n    b: number;\n}\ninterface Animal extends Animal1, Animal2 {\n    ...\n} // interface 可以使用extends集成\nclass Animal implements Animal1, Animal2 {\n    ...\n} // 也可以使用class的extends和implements进行继承\n```\n\n###### 可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作\n\n```typescript\nconst defaultData = {\n    name: string;\n    age: number;\n}\ntype IDefaultData = typeof defaultData // {name: string; age: number}\ntype Ikeys = keyof defaultData\n```\n\n###### 同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算\n\n```typescript\nconst defaultData = {\n    name: string;\n    age: number;\n}\ntype IDefaultData = typeof defaultData // {name: string; age: number}\ntype Ikeys = keyof defaultData\n\ntype IData = Record<string, typeof defaultData>;\ntype IList  = Record<string, Pick<IDefaultData, 'name'> & {sex: number}>\n```\n\n```typescript\ntype Foo<T> = T extends { a: infer U; b: infer U } ? U : never;\ntype T0 = Foo<{a: string, b: string}> // string\ntype T1 = Foo<{a: string, b: number}> // string | number\ntype T6 = Foo<{a: number, c: string, b: symbol}> // symbol\n```\n\n<ul><li><strong>类型的推导</strong></li></ul>\n\n###### 类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\n\n```typescript\ntype Foo1 = {\n    a: A1 //就当它是A1类型吧\n    b: B1 // 就当它是B1类型吧\n}\n\ntype Foo2 = Record<keyof Foo1, Foo>\n```\n\n###### 而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\n\n```typescript\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n```\n\n<ul><li><strong>类型的条件语句</strong></li></ul>\n\n###### 这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // ok👌， arg 受Lengthwise约束，因此lenght是有的\n  return arg;\n}\n```\n\n```typescript\ntype Foo<T extends 0 | 1 | 2> = T extends 0 | 1 ? `${T}${N}` : `${T}${0|1|2|3}`\n// 也可以通过extends的约束功能给类型做一个三元表达的条件语句运算`\n```\n\n<ul><li><strong>类型的循环遍历</strong></li></ul>\n\n既然是可以编程的，那就不可以缺少循环遍历的语句了。ts的类型也是可以通过[in]对类型进行循环遍历的。同样的，这只能在type中使用\n\n```typescript\ntype Foo = {\n    a: string;\n    b: number;\n    c: boolean;\n    d: symbol;\n}\ntype A = {\n    [k in keyof Foo]: B;\n}\n// {a: B; b: B; c: B; d: B}\n\ninterface A {\n    [k in keyof Foo]: B;\n} // error,别问为什么不可以，语言就是这样\n```\n\n###### 甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\n\n```typescript\ntype Foo = {\n    a: string;\n    b: number;\n    c: boolean;\n    d: symbol;\n}\ntype A = {\n    [ `get${k}` in keyof Foo]: B;\n}\n// {geta: B; getb: B; getc: B; getd: B}\n\n```\n\n###### 同样，作为\n\n<ul><li><strong>静态数据的类型</strong></li></ul>\n\n###### 说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时\n\n```typescript\ntype Foo  = {\n    status: number;\n}\ntype Foo = {\n    mode: string;\n}\n```\n\n###### 这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\n\n```typescript\nif(status === 0) {\n    // do something\n}\nif (mode === 'xxx') {\n    // do something\n}\n```\n\n###### 这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试\n\n```typescript\nif(status === 0) {\n    // do something\n}\nif (mode === 'xxx') {\n    // do something\n}\n```\n\n###### 如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\n\n```typescript\nenum IStatus {\n    off,\n    on\n} // {off: 0, on: 1}\ntype Foo  = {\n    status: Istatus;\n}// 在之后的过程中都可以使用这个IStatus枚举\n```\n\n###### 通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const\n\n```typescript\ncosnt arr = ['a', 'b', 'c'] \ntype Foo = typeof arr // string[]\n// 这个时候ts的反推类型就是string[]\n```\n\n```typescript\ncosnt arr = ['a', 'b', 'c'] as const\ntype Foo = typeof arr // ['a', 'b', 'c']\n// 这个时候ts的反推类型就是只读熟悉了，它可以用来弥补readonly的一些缺陷\n```\n\n<ul><li><strong>动态类型的定义</strong></li></ul>\n\n###### 是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\n\n```typescript\nconst foo = <T extends {type: 'a'|'b', val: any}>(arg: T) => {\n    switch (arg.type){\n        case 'a': ...\n        case 'b': ...\n    }\n    return arg.val\n}\n```\n\n```typescript\nclass Foo<T, U> {\n    a: T\n    b: U\n    foo: (a: T) => void\n}\n```\n\n###### 类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起\n\n```typescript\nexport declare type ProSchema<T = Record<string, unknown>, Extra = unknown, V = ProSchemaComponentTypes, ValueType = 'text'> = {\n    /** @name 确定这个列的唯一值 */\n    key?: React.ReactText;\n    /**\n     * 支持一个数字，[a,b] 会转化为 obj.a.b\n     *\n     * @name 与实体映射的key\n     */\n    dataIndex?: keyof T;\n\n    render?: (dom: React.ReactNode, entity: T, index: number, action: ProCoreActionType, schema: ProSchema<T, Extra> & {\n        isEditable?: boolean;\n        type: V;\n    }) => React.ReactNode;\n}\n```\n\n###### 处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\n","source":"_posts/typecript，让类型约束成为一种习惯.md","raw":"---\ntitle: typecript，让类型约束成为一种习惯\ndate: 2022-01-08 18:36:31\ntags: typescript 类型编程\ndescription: 伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一\n---\n## 基础知识概述\n\n伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一。\n\n ts类型并不是只能有类型定义，然后给逻辑代码用这么简单。也并不是说代码懂得了一个any这样的全能类型，然后就到处使用any，只关心逻辑代码这块（能跑就行！！！！）。\n\n<h2>1、是开发和维护过程中的工具</h2>\n\n对于ts类型，他也是有自己的编程逻辑的。对于它，我们可以将它理解成一个我们项目开发与维护的工具，这个取决于我们对这个工具的了解程度和利用的程度，利用的好，它是规范我们的逻辑代码的一大利器，代码中的变量便会在明确的类型指引下快速且高效的开发。\n\n<ul><li><strong>约束某一块代码的具体功能</strong></li></ul>\n\n比如说在一个函数中，我们因为有了一个函数的约束，我们可以很明确的知道这个段逻辑块要完成的是一个什么样的功能，不得不说的是，很多人觉得ts是个累赘，那就是很多人都是先写逻辑，后写类型的，就是一种差不多的想法，代码能跑就行，最后只能写成了anyscript。 比如说：\n\n```typescript\nconst foo = (arg: A): B => {\n    // do something....\n}\n```\n\n我们便能知道这个函数是一个要将A类型的变量处理处理成B类型的函数，这段代码有这样的作用就通过类型就可以显而易见了，当然前提是A和B的类型是明确的，不能写一个any，Object草草了事，当然在返回类型是也要尽量的准确点，比如说，有的时候为了一个求一个逻辑代码写的顺畅，盲目的让类型迎合变量。\n\n```typescript\nconst foo = (a: A): string | number | boolean => {\n    // do something...\n}\n```\n\n```typescript\nconst foo = (a: string | number | object | boolean): B => {\n    // do something...\n}\n```\n\n这样的做法在ts编程的时候是不可取（不建议）的，其实在纯js中也是不建议这样的，这样失去了逻辑快单一功能的原则，会让后续的对它的维护显得特别的困难，在之后的调试过程中也会显得格外的困难。\n\n可能，我们会真的碰到这个函数逻辑就是要这样的耦合，那么我们不妨试试另一种类型声明的方式。\n\n```typescript\ninterface foo {(a: A, b: string): void} // 参数a为类型A时，那么b的类型为string\ninterface foo {(a: B, b: number): void} // 参数a为类型B时，那么b的类型为number\ninterface foo {(a: C, b: number): D} // 参数a为类型C时，那么b的类型为number，且函数会有返回值D。\n```\n\n这三个都是给一个函数声明类型，然后可以很有效的做到逻辑耦合但是类型不耦合，同时也对函数的调用起到了类型校验的作用，不再是像以前写着一个联合类型，让人调用函数的时候觉得这个类型有点傻乎乎的样子，什么也不懂。\n\n这样的方式可以在很大的程度上，让函数的调用变得轻松，不至于让写出的东西让别人无法调用或者类型靠as去断言。\n\n```typescript\ndeclare interface Foo {\n  (a: string, b: string): void;\n}// 参数a为类型string时，那么b的类型为string\ndeclare interface Foo {(a: boolean, b: number): void} // 参数a为类型boolean时，那么b的类型为number\nconst foo: Foo = (a: string | boolean, b: number | string) => {\n  // do something......\n}\n\nfoo('1', 2); // error,a为string类型时，b参数的类型为string\nfoo(false, 2); // ok👌\nfoo(true, '2') // error,第一个参数为boolean时，第二个参数必须为数字\n```\n\n###### 注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\n\n 对于函数的逻辑块的类型声明可以这样，同理，组件中我们也可以做到。 其实组件中特别是想要复用性高一点的组件，一般都不会太建议太高的耦合度了，但是，方法也是有的了。\n\n在react中，如果是函数式组件，我们可以跟上面说的函数定义一样的去做\n\n```typescript\ninterface IProps {\n    a: A1;\n    b: B1;\n};\ninterface IProps {\n    a: A2;\n    b: B2;\n}\nconst ComponentA: React.FC<IProps>;\n```\n\n同样，这样的耦合度对于这个组件的编写还是不太好的，但是很大程度上可以简化组件的调用，让别人可以更好的去调用它。 在class组件中，这样的做法会显得更加简便\n\n```typescript\ninterface ComponentA {\n    props: {....}\n    func(): A\n}\ninterface ComponentA {\n    props: {....}\n}\nclass ComponentA extends Component {\n    constructor() {\n        this.state = {.....}\n    }\n    render() {\n        return (....)\n    }\n}\n```\n\n这样子对组件的编写过程起到的作用还是比较小的，但是对于组件的调用却有很大的意义，它可以查出组件错误的调用方式。\n\n<ul><li><strong>约束静态数据</strong></li></ul>\n\n作为工具，说白了就是没有它也一样，照样可以做出我想要的东西。但是ts能够一直发展过来，能够受到这么多的前端开发者的青睐自有它的原因。它确实是可以很好的去约束我们的代码，约束我们开发过程中所制造出的各种数据，这个也是取决于，自己对ts的理解程度的。 比如说我们在定义如下数据的类型时\n\n```typescript\nconst schedule = {\n  '00:00': 0,\n  '00:30': 0,\n  '01:00': 0,\n   // ..... 省略，每隔30一个\n  '12:00': 0,\n  '12:30': 1,\n  '13:00': 1,\n  '13:30': 1,\n  '22:30': 0,\n  '23:00': 0,\n  '23:30': 0,\n};\n```\n\n在只知道interface，type的时候会一项一项的列出来\n\n```typescript\ntype ISchedule = {\n  '00:00': number,\n  '00:30': number,\n  '01:00': number,\n   // ..... 省略，每隔30一个\n};\n```\n\n然后再深入，知道了[in]，然后又会觉得，类型不过如此，会直接在写出\n\n```typescript\ntype ISchedule = {\n    [k in string]: number\n}\n```\n\n之后，更加深入的去知道了自带的工具类型\n\n```typescript\ntype ISchedule = {\n    [k in string]: number\n}\n```\n\n很明显，对ts的使用程度就可以体现出来了，写法的不同，ts发挥的作用也都是不同的。\n\n 后面两种的写法很明显只是为了规避eslint的报错而写的类型的，定义太宽泛，这个时候如果是前端自己写类型定义可以使用类型的模板字符串\n\n```typescript\ntype N = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0\ntype Time<T extends 0 | 1 | 2> = T extends 0 | 1 ? `${T}${N}` : `${T}${0|1|2|3}`\nenum CheckEnum {}\ntype A = Record<`${Time<0 | 1> | Time<2>}:${'00' | '30'}`, CheckEnum>\n```\n\n模板字符串，它集成了[in]语法糖，让所有的可能类型自由组合，可以自动对所有的情况做一次遍历。 当然这样写只是为了提示一下ts的新特性中还有类型模板字符串，但是也可以看得出，ts的类型也越来越完善，可以让类型定义的越来越精确。有了这个模板字符串，很多的以前我们就写一个string的类型，我们都可以给定一个更加精确的定义，来保证我们的类型的准确性 比如说，我们给request定义url的时候我们就可以不写string，完全可以定义一个独有的IUrl类型，来规范url的编写。\n\n```typescript\ntype IUrl = `/${string}`\nexport request = <R>(url: IUrl, options) => Promise<T>\n```\n\n这样就可以避免犯前面忘了加 / 这样的低级错误。 此外，类型模版字符串甚至可以用于校验电话号码，时间格式等字符串类型的数据，预防静态数据认为输入是校验太少而出现的错误。\n\n<ul><li><strong>类型的断言</strong></li></ul>\n\n其实ts作为工具，它和eslint的功能差不多，都是一个规范代码书写，可快发提效的手段。同时也会遇到一些ts无法准确做出判断的时候，毕竟ts是不参与逻辑代码的计算的，应该说，是不支持解耦之后的代码的类型运算。\n\n```typescript\ntype Foo1 = {\n  value: number,\n  type: 'a'\n}\ntype Foo2 = {\n  value: string,\n  type: 'b'\n}\nconst foo = (arg: Foo1 | Foo2) => {\n  if (arg.type === 'a'){\n    // arg is Foo1\n    console.log(arg)\n  }\n  if (arg.type === 'b') {\n    // arg is F002\n    console.log(arg)\n  }\n}\n```\n\n在这种前后耦合的情况下类型还是可以会能有自己的推导的，具体的，可以去看类型的合成与拆分，这也是在某个函数一定要耦合的时候建议的做法。\n\n###### 好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\n\n```typescript\n<Dialog visible={!!data} close={data.close}> // error, data可能为undefined\n // some thing\n</Dialog>\n```\n\n这种情况下就难免会给data定义undefined的联合类型的了，到了一些方法中，这个主要是因为数据与视图解耦了，ts就会提醒你某个参数有可能为undefined，但是为undefined的时候数据都是不执行的，其实前面做一个非空检验也没什么大不了的，但是这个时候就看的出ts就比较傻了，此时我们的断言就可以用上了\n\n```typescript\n<Dialog visible={!!data} close={data!.close}> // ok, 这里可以用一个非空断言\n // some thing\n</Dialog>\n```\n\n大部分的时候非空断言( ! )，我们基本上就够用了，可以解决大部分类型推导不过来的问题。\n\n但是还有很多时候，ts的使用程度不同的人会出现不一样的情况，有的人对类型的定义严格，有的人定义的宽松，为什么会这样可以看前面的概述。但是问题还是要解决的，我们这个时候如果真的非常肯定不会出问题，那么我们不妨试试as断言。\n\n```typescript\ntype Foo1 = {\n  value: number ｜ string,\n  type: string\n}\ntype Foo2 = {\n  value: string,\n  type: 'b'\n}\nconst foo = (arg: Foo2) => {\n  // do something\n}\nconst a: Foo1 = {\n    .....\n}\nfoo(a) // error, Foo1类型不能给Foo2类型！\nfoo(a as Foo2) //ok，Foo2类型只是比Foo1类型更小，此处的断言可以告诉ts，我比你更清楚这个数据\n```\n\n从这个小例子中我们可以看出，断言对很多类型逃避主义的人其实也是一个非常大的福音，类型定义的时候宽泛就好了，衔接不上的时候直接as unknown as ...、as any as ...。如果有这种的行为，我也只能说，干的漂亮！ts技术又有了一点提升，只要代码能跑，还真让别人挑不出一点ts的毛病。 话说回来，还是好好的重视类型报错、严格的定义类型吧，如果真的是有非要有耦合的情况，可以看看上面本节的第一点说的方法吧。ts要不了多少时间的，真的可以避免错误，还有减少很多找bug的时间。\n\n<ul><li><strong>全局类型声明</strong></li></ul>\n\n应该很多人想过一个问题，为什么我们可以不需要引入，就可以用Record、Omit、Partail这样的工具类型。还有就是，我们自己开发过程中其实也写出了很多的好用的类型，有的是可以完全脱离某个项目，直接到处都可以用的，比如说我们Omit的源码。\n\n```typescript\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n```\n\n###### 它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\n\n```typescript\ntype MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n```\n\n###### 这样就可以使得MyOmit更符合我们的需求\n\n###### 下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\n\n###### 其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了\n\n```typescript\n// public.d.ts\ndeclare type MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n```\n\n这样就好了，就可以在整个项目中使用了。\n\n如果你以为这一点就这么完了，那你想的肯定是太简单了，另外拓展一下，其实类型也是可以改写的😂😂。\n\n比如说，在使用Object.entries的时候，通过lib.es2017.d.ts中的源码可以看到，entries的类型定义还是有点不太好，不太适合日常的ts类型开发。\n\n```typescript\n     /**\n         * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries<T>(o: { [s: string]: T } | ArrayLike<T>): [string, T][];\n```\n\n这个时候，我们就可以考虑一下改写它的类型，当然不是去修改编辑器的代码，别想太多。\n\n```typescript\n// .d.ts\ndeclare interface ObjectConstructor {\n  entries<T>(obj: T): [keyof T, T[keyof T]][];\n}\n```\n\n<h2>2、是一个具有编程思想的语言</h2>\n\n###### 上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\n\n<ul><li><strong>interface、type、class的区别</strong></li></ul>\n\n###### 很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别\n\n###### 1、type，class定义的类型不可以重复，interface定义的类型可以重复\n\n```typescript\ntype Record = {...} // error, Record已经被定义过\ninterface ObjectConstructor {\n    ......\n} // ok👌，interface 定义的类型可以重复定义，重新给Object的一些原型方法写类型\n```\n\n###### 这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以\n\n```typescript\ntype Keys = \"小王\" | \"小文\"\ntype X = {\n  [key in Keys]: string\n}\nconst test: X = {\n    '小王': '肌肉男',\n    '小文': '也是肌肉男'\n}\n\ninterface XX {\n    [k in keys]: string // error!!!\n}\n```\n\n###### 3、interface，class使用extends、implements组合类型，type则可以通过&, |符号组合、合并类型\n\n```typescript\ninterface Animals1 {\n    ...\n}\ninterface Animals2 {\n    ...\n}\ninterface Cat extends Animals1, Animals2 {\n    ...\n}\n\ntype Dog = Animals1 & Animals2 & {\n    ...\n}\n```\n\n###### 4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\n\n```typescript\n// a.d.ts\nexport interface Foo {\n    aa: string;\n    ....\n}\n// {aa: string, ...}\n```\n\n```typescript\n// b.d.ts\nimport type { Foo } from 'a'\ninterface Foo {\n    aa: number;\n    ...\n}\n// {aa: number; ...}\n```\n\n###### 5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\n\n```typescript\nconst foo = {\n    a: 'a',\n    b: 2,\n    c: true\n}\ntype Foo = typeof foo //{ a: string, b: 2, c: boolean }\n```\n\n从以上的几点区别可以看出，类型的定义上，interface和class更像是给ecmascript增加了接口的概念，让类型与代码可以耦合，真正的将js变成了强类型语言（当然总是联合类型就另说了，基本上不会在意这么多了，基本上就不会管类型声明上的区别了）。\n\n```typescript\ninterface Animal1 {\n    a: string;\n}\ninterface Animal2 {\n    b: number;\n}\ninterface Animal extends Animal1, Animal2 {\n    ...\n} // interface 可以使用extends集成\nclass Animal implements Animal1, Animal2 {\n    ...\n} // 也可以使用class的extends和implements进行继承\n```\n\n###### 可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作\n\n```typescript\nconst defaultData = {\n    name: string;\n    age: number;\n}\ntype IDefaultData = typeof defaultData // {name: string; age: number}\ntype Ikeys = keyof defaultData\n```\n\n###### 同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算\n\n```typescript\nconst defaultData = {\n    name: string;\n    age: number;\n}\ntype IDefaultData = typeof defaultData // {name: string; age: number}\ntype Ikeys = keyof defaultData\n\ntype IData = Record<string, typeof defaultData>;\ntype IList  = Record<string, Pick<IDefaultData, 'name'> & {sex: number}>\n```\n\n```typescript\ntype Foo<T> = T extends { a: infer U; b: infer U } ? U : never;\ntype T0 = Foo<{a: string, b: string}> // string\ntype T1 = Foo<{a: string, b: number}> // string | number\ntype T6 = Foo<{a: number, c: string, b: symbol}> // symbol\n```\n\n<ul><li><strong>类型的推导</strong></li></ul>\n\n###### 类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\n\n```typescript\ntype Foo1 = {\n    a: A1 //就当它是A1类型吧\n    b: B1 // 就当它是B1类型吧\n}\n\ntype Foo2 = Record<keyof Foo1, Foo>\n```\n\n###### 而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\n\n```typescript\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n```\n\n<ul><li><strong>类型的条件语句</strong></li></ul>\n\n###### 这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // ok👌， arg 受Lengthwise约束，因此lenght是有的\n  return arg;\n}\n```\n\n```typescript\ntype Foo<T extends 0 | 1 | 2> = T extends 0 | 1 ? `${T}${N}` : `${T}${0|1|2|3}`\n// 也可以通过extends的约束功能给类型做一个三元表达的条件语句运算`\n```\n\n<ul><li><strong>类型的循环遍历</strong></li></ul>\n\n既然是可以编程的，那就不可以缺少循环遍历的语句了。ts的类型也是可以通过[in]对类型进行循环遍历的。同样的，这只能在type中使用\n\n```typescript\ntype Foo = {\n    a: string;\n    b: number;\n    c: boolean;\n    d: symbol;\n}\ntype A = {\n    [k in keyof Foo]: B;\n}\n// {a: B; b: B; c: B; d: B}\n\ninterface A {\n    [k in keyof Foo]: B;\n} // error,别问为什么不可以，语言就是这样\n```\n\n###### 甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\n\n```typescript\ntype Foo = {\n    a: string;\n    b: number;\n    c: boolean;\n    d: symbol;\n}\ntype A = {\n    [ `get${k}` in keyof Foo]: B;\n}\n// {geta: B; getb: B; getc: B; getd: B}\n\n```\n\n###### 同样，作为\n\n<ul><li><strong>静态数据的类型</strong></li></ul>\n\n###### 说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时\n\n```typescript\ntype Foo  = {\n    status: number;\n}\ntype Foo = {\n    mode: string;\n}\n```\n\n###### 这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\n\n```typescript\nif(status === 0) {\n    // do something\n}\nif (mode === 'xxx') {\n    // do something\n}\n```\n\n###### 这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试\n\n```typescript\nif(status === 0) {\n    // do something\n}\nif (mode === 'xxx') {\n    // do something\n}\n```\n\n###### 如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\n\n```typescript\nenum IStatus {\n    off,\n    on\n} // {off: 0, on: 1}\ntype Foo  = {\n    status: Istatus;\n}// 在之后的过程中都可以使用这个IStatus枚举\n```\n\n###### 通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const\n\n```typescript\ncosnt arr = ['a', 'b', 'c'] \ntype Foo = typeof arr // string[]\n// 这个时候ts的反推类型就是string[]\n```\n\n```typescript\ncosnt arr = ['a', 'b', 'c'] as const\ntype Foo = typeof arr // ['a', 'b', 'c']\n// 这个时候ts的反推类型就是只读熟悉了，它可以用来弥补readonly的一些缺陷\n```\n\n<ul><li><strong>动态类型的定义</strong></li></ul>\n\n###### 是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\n\n```typescript\nconst foo = <T extends {type: 'a'|'b', val: any}>(arg: T) => {\n    switch (arg.type){\n        case 'a': ...\n        case 'b': ...\n    }\n    return arg.val\n}\n```\n\n```typescript\nclass Foo<T, U> {\n    a: T\n    b: U\n    foo: (a: T) => void\n}\n```\n\n###### 类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起\n\n```typescript\nexport declare type ProSchema<T = Record<string, unknown>, Extra = unknown, V = ProSchemaComponentTypes, ValueType = 'text'> = {\n    /** @name 确定这个列的唯一值 */\n    key?: React.ReactText;\n    /**\n     * 支持一个数字，[a,b] 会转化为 obj.a.b\n     *\n     * @name 与实体映射的key\n     */\n    dataIndex?: keyof T;\n\n    render?: (dom: React.ReactNode, entity: T, index: number, action: ProCoreActionType, schema: ProSchema<T, Extra> & {\n        isEditable?: boolean;\n        type: V;\n    }) => React.ReactNode;\n}\n```\n\n###### 处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\n","slug":"typecript，让类型约束成为一种习惯","published":1,"updated":"2022-03-06T04:55:30.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eypmz30000kqfyhn9chvei","content":"<h2 id=\"基础知识概述\"><a href=\"#基础知识概述\" class=\"headerlink\" title=\"基础知识概述\"></a>基础知识概述</h2><p>伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一。</p>\n<p> ts类型并不是只能有类型定义，然后给逻辑代码用这么简单。也并不是说代码懂得了一个any这样的全能类型，然后就到处使用any，只关心逻辑代码这块（能跑就行！！！！）。</p>\n<h2>1、是开发和维护过程中的工具</h2>\n\n<p>对于ts类型，他也是有自己的编程逻辑的。对于它，我们可以将它理解成一个我们项目开发与维护的工具，这个取决于我们对这个工具的了解程度和利用的程度，利用的好，它是规范我们的逻辑代码的一大利器，代码中的变量便会在明确的类型指引下快速且高效的开发。</p>\n<ul><li><strong>约束某一块代码的具体功能</strong></li></ul>\n\n<p>比如说在一个函数中，我们因为有了一个函数的约束，我们可以很明确的知道这个段逻辑块要完成的是一个什么样的功能，不得不说的是，很多人觉得ts是个累赘，那就是很多人都是先写逻辑，后写类型的，就是一种差不多的想法，代码能跑就行，最后只能写成了anyscript。 比如说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">arg</span>: A): <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们便能知道这个函数是一个要将A类型的变量处理处理成B类型的函数，这段代码有这样的作用就通过类型就可以显而易见了，当然前提是A和B的类型是明确的，不能写一个any，Object草草了事，当然在返回类型是也要尽量的准确点，比如说，有的时候为了一个求一个逻辑代码写的顺畅，盲目的让类型迎合变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">a</span>: A): <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"function\"><span class=\"params\">boolean</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">object</span> | <span class=\"built_in\">boolean</span>): <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的做法在ts编程的时候是不可取（不建议）的，其实在纯js中也是不建议这样的，这样失去了逻辑快单一功能的原则，会让后续的对它的维护显得特别的困难，在之后的调试过程中也会显得格外的困难。</p>\n<p>可能，我们会真的碰到这个函数逻辑就是要这样的耦合，那么我们不妨试试另一种类型声明的方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: A, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型A时，那么b的类型为string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: B, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型B时，那么b的类型为number</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: C, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): D&#125; <span class=\"comment\">// 参数a为类型C时，那么b的类型为number，且函数会有返回值D。</span></span><br></pre></td></tr></table></figure>\n\n<p>这三个都是给一个函数声明类型，然后可以很有效的做到逻辑耦合但是类型不耦合，同时也对函数的调用起到了类型校验的作用，不再是像以前写着一个联合类型，让人调用函数的时候觉得这个类型有点傻乎乎的样子，什么也不懂。</p>\n<p>这样的方式可以在很大的程度上，让函数的调用变得轻松，不至于让写出的东西让别人无法调用或者类型靠as去断言。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  (<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 参数a为类型string时，那么b的类型为string</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;(<span class=\"attr\">a</span>: <span class=\"built_in\">boolean</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型boolean时，那么b的类型为number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">foo</span>: <span class=\"title class_\">Foo</span> = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span>, b: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"number\">2</span>); <span class=\"comment\">// error,a为string类型时，b参数的类型为string</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">false</span>, <span class=\"number\">2</span>); <span class=\"comment\">// ok👌</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">true</span>, <span class=\"string\">&#x27;2&#x27;</span>) <span class=\"comment\">// error,第一个参数为boolean时，第二个参数必须为数字</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\"><a href=\"#注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\" class=\"headerlink\" title=\"注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\"></a>注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别</h6><p> 对于函数的逻辑块的类型声明可以这样，同理，组件中我们也可以做到。 其实组件中特别是想要复用性高一点的组件，一般都不会太建议太高的耦合度了，但是，方法也是有的了。</p>\n<p>在react中，如果是函数式组件，我们可以跟上面说的函数定义一样的去做</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IProps</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A1</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IProps</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A2</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ComponentA</span>: <span class=\"title class_\">React</span>.<span class=\"property\">FC</span>&lt;<span class=\"title class_\">IProps</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>同样，这样的耦合度对于这个组件的编写还是不太好的，但是很大程度上可以简化组件的调用，让别人可以更好的去调用它。 在class组件中，这样的做法会显得更加简便</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ComponentA</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;....&#125;</span><br><span class=\"line\">    <span class=\"title function_\">func</span>(): A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ComponentA</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;....&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComponentA</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;.....&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (....)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子对组件的编写过程起到的作用还是比较小的，但是对于组件的调用却有很大的意义，它可以查出组件错误的调用方式。</p>\n<ul><li><strong>约束静态数据</strong></li></ul>\n\n<p>作为工具，说白了就是没有它也一样，照样可以做出我想要的东西。但是ts能够一直发展过来，能够受到这么多的前端开发者的青睐自有它的原因。它确实是可以很好的去约束我们的代码，约束我们开发过程中所制造出的各种数据，这个也是取决于，自己对ts的理解程度的。 比如说我们在定义如下数据的类型时</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> schedule = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;01:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">   <span class=\"comment\">// ..... 省略，每隔30一个</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;12:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;12:30&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;13:00&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;13:30&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;22:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;23:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;23:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在只知道interface，type的时候会一项一项的列出来</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:00&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:30&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;01:00&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">   <span class=\"comment\">// ..... 省略，每隔30一个</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后再深入，知道了[in]，然后又会觉得，类型不过如此，会直接在写出</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，更加深入的去知道了自带的工具类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显，对ts的使用程度就可以体现出来了，写法的不同，ts发挥的作用也都是不同的。</p>\n<p> 后面两种的写法很明显只是为了规避eslint的报错而写的类型的，定义太宽泛，这个时候如果是前端自己写类型定义可以使用类型的模板字符串</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> N = <span class=\"number\">1</span> | <span class=\"number\">2</span> | <span class=\"number\">3</span> | <span class=\"number\">4</span> | <span class=\"number\">5</span> | <span class=\"number\">6</span> | <span class=\"number\">7</span> | <span class=\"number\">8</span> | <span class=\"number\">9</span> | <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Time</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> | <span class=\"number\">2</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> ? <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;N&#125;</span>`</span> : <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">CheckEnum</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = <span class=\"title class_\">Record</span>&lt;<span class=\"string\">`<span class=\"subst\">$&#123;Time&lt;<span class=\"number\">0</span> | <span class=\"number\">1</span>&gt; | Time&lt;<span class=\"number\">2</span>&gt;&#125;</span>:<span class=\"subst\">$&#123;<span class=\"string\">&#x27;00&#x27;</span> | <span class=\"string\">&#x27;30&#x27;</span>&#125;</span>`</span>, <span class=\"title class_\">CheckEnum</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>模板字符串，它集成了[in]语法糖，让所有的可能类型自由组合，可以自动对所有的情况做一次遍历。 当然这样写只是为了提示一下ts的新特性中还有类型模板字符串，但是也可以看得出，ts的类型也越来越完善，可以让类型定义的越来越精确。有了这个模板字符串，很多的以前我们就写一个string的类型，我们都可以给定一个更加精确的定义，来保证我们的类型的准确性 比如说，我们给request定义url的时候我们就可以不写string，完全可以定义一个独有的IUrl类型，来规范url的编写。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IUrl</span> = <span class=\"string\">`/<span class=\"subst\">$&#123;<span class=\"built_in\">string</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> request = &lt;R&gt;<span class=\"function\">(<span class=\"params\">url: IUrl, options</span>) =&gt;</span> <span class=\"title class_\">Promise</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以避免犯前面忘了加 &#x2F; 这样的低级错误。 此外，类型模版字符串甚至可以用于校验电话号码，时间格式等字符串类型的数据，预防静态数据认为输入是校验太少而出现的错误。</p>\n<ul><li><strong>类型的断言</strong></li></ul>\n\n<p>其实ts作为工具，它和eslint的功能差不多，都是一个规范代码书写，可快发提效的手段。同时也会遇到一些ts无法准确做出判断的时候，毕竟ts是不参与逻辑代码的计算的，应该说，是不支持解耦之后的代码的类型运算。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;b&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: Foo1 | Foo2</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arg.<span class=\"property\">type</span> === <span class=\"string\">&#x27;a&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// arg is Foo1</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arg.<span class=\"property\">type</span> === <span class=\"string\">&#x27;b&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// arg is F002</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种前后耦合的情况下类型还是可以会能有自己的推导的，具体的，可以去看类型的合成与拆分，这也是在某个函数一定要耦合的时候建议的做法。</p>\n<h6 id=\"好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\"><a href=\"#好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\" class=\"headerlink\" title=\"好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\"></a>好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Dialog</span> visible=&#123;!!data&#125; close=&#123;data.<span class=\"property\">close</span>&#125;&gt; <span class=\"comment\">// error, data可能为undefined</span></span><br><span class=\"line\"> <span class=\"comment\">// some thing</span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下就难免会给data定义undefined的联合类型的了，到了一些方法中，这个主要是因为数据与视图解耦了，ts就会提醒你某个参数有可能为undefined，但是为undefined的时候数据都是不执行的，其实前面做一个非空检验也没什么大不了的，但是这个时候就看的出ts就比较傻了，此时我们的断言就可以用上了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Dialog</span> visible=&#123;!!data&#125; close=&#123;data!.<span class=\"property\">close</span>&#125;&gt; <span class=\"comment\">// ok, 这里可以用一个非空断言</span></span><br><span class=\"line\"> <span class=\"comment\">// some thing</span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>大部分的时候非空断言( ! )，我们基本上就够用了，可以解决大部分类型推导不过来的问题。</p>\n<p>但是还有很多时候，ts的使用程度不同的人会出现不一样的情况，有的人对类型的定义严格，有的人定义的宽松，为什么会这样可以看前面的概述。但是问题还是要解决的，我们这个时候如果真的非常肯定不会出问题，那么我们不妨试试as断言。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> ｜ <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;b&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: Foo2</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a) <span class=\"comment\">// error, Foo1类型不能给Foo2类型！</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a <span class=\"keyword\">as</span> <span class=\"title class_\">Foo2</span>) <span class=\"comment\">//ok，Foo2类型只是比Foo1类型更小，此处的断言可以告诉ts，我比你更清楚这个数据</span></span><br></pre></td></tr></table></figure>\n\n<p>从这个小例子中我们可以看出，断言对很多类型逃避主义的人其实也是一个非常大的福音，类型定义的时候宽泛就好了，衔接不上的时候直接as unknown as …、as any as …。如果有这种的行为，我也只能说，干的漂亮！ts技术又有了一点提升，只要代码能跑，还真让别人挑不出一点ts的毛病。 话说回来，还是好好的重视类型报错、严格的定义类型吧，如果真的是有非要有耦合的情况，可以看看上面本节的第一点说的方法吧。ts要不了多少时间的，真的可以避免错误，还有减少很多找bug的时间。</p>\n<ul><li><strong>全局类型声明</strong></li></ul>\n\n<p>应该很多人想过一个问题，为什么我们可以不需要引入，就可以用Record、Omit、Partail这样的工具类型。还有就是，我们自己开发过程中其实也写出了很多的好用的类型，有的是可以完全脱离某个项目，直接到处都可以用的，比如说我们Omit的源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Omit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\"><a href=\"#它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\" class=\"headerlink\" title=\"它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\"></a>它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样就可以使得MyOmit更符合我们的需求\"><a href=\"#这样就可以使得MyOmit更符合我们的需求\" class=\"headerlink\" title=\"这样就可以使得MyOmit更符合我们的需求\"></a>这样就可以使得MyOmit更符合我们的需求</h6><h6 id=\"下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\"><a href=\"#下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\" class=\"headerlink\" title=\"下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\"></a>下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？</h6><h6 id=\"其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了\"><a href=\"#其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了\" class=\"headerlink\" title=\"其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了\"></a>其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这样就好了，就可以在整个项目中使用了。</p>\n<p>如果你以为这一点就这么完了，那你想的肯定是太简单了，另外拓展一下，其实类型也是可以改写的😂😂。</p>\n<p>比如说，在使用Object.entries的时候，通过lib.es2017.d.ts中的源码可以看到，entries的类型定义还是有点不太好，不太适合日常的ts类型开发。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an array of key/values of the enumerable properties of an object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">entries&lt;T&gt;(<span class=\"attr\">o</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: T &#125; | <span class=\"title class_\">ArrayLike</span>&lt;T&gt;): [<span class=\"built_in\">string</span>, T][];</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，我们就可以考虑一下改写它的类型，当然不是去修改编辑器的代码，别想太多。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">  entries&lt;T&gt;(<span class=\"attr\">obj</span>: T): [keyof T, T[keyof T]][];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2>2、是一个具有编程思想的语言</h2>\n\n<h6 id=\"上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\"><a href=\"#上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\" class=\"headerlink\" title=\"上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\"></a>上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利</h6><ul><li><strong>interface、type、class的区别</strong></li></ul>\n\n<h6 id=\"很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别\"><a href=\"#很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别\" class=\"headerlink\" title=\"很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别\"></a>很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别</h6><h6 id=\"1、type，class定义的类型不可以重复，interface定义的类型可以重复\"><a href=\"#1、type，class定义的类型不可以重复，interface定义的类型可以重复\" class=\"headerlink\" title=\"1、type，class定义的类型不可以重复，interface定义的类型可以重复\"></a>1、type，class定义的类型不可以重复，interface定义的类型可以重复</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Record</span> = &#123;...&#125; <span class=\"comment\">// error, Record已经被定义过</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; <span class=\"comment\">// ok👌，interface 定义的类型可以重复定义，重新给Object的一些原型方法写类型</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以\"><a href=\"#这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以\" class=\"headerlink\" title=\"这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以\"></a>这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Keys</span> = <span class=\"string\">&quot;小王&quot;</span> | <span class=\"string\">&quot;小文&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> X = &#123;</span><br><span class=\"line\">  [key <span class=\"keyword\">in</span> <span class=\"title class_\">Keys</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">test</span>: X = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;小王&#x27;</span>: <span class=\"string\">&#x27;肌肉男&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;小文&#x27;</span>: <span class=\"string\">&#x27;也是肌肉男&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> XX &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keys]: <span class=\"built_in\">string</span> <span class=\"comment\">// error!!!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型\"><a href=\"#3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型\" class=\"headerlink\" title=\"3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型\"></a>3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animals1</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animals2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animals1</span>, <span class=\"title class_\">Animals2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> = <span class=\"title class_\">Animals1</span> &amp; <span class=\"title class_\">Animals2</span> &amp; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\"><a href=\"#4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\" class=\"headerlink\" title=\"4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\"></a>4、interface定义的类型可以被改写，type、class定义的类型不可以被改写</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">aa</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;aa: string, ...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">Foo</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">aa</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;aa: number; ...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\"><a href=\"#5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\" class=\"headerlink\" title=\"5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\"></a>5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> foo <span class=\"comment\">//&#123; a: string, b: 2, c: boolean &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从以上的几点区别可以看出，类型的定义上，interface和class更像是给ecmascript增加了接口的概念，让类型与代码可以耦合，真正的将js变成了强类型语言（当然总是联合类型就另说了，基本上不会在意这么多了，基本上就不会管类型声明上的区别了）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal1</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal1</span>, <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// interface 可以使用extends集成</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal1</span>, <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// 也可以使用class的extends和implements进行继承</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作\"><a href=\"#可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作\" class=\"headerlink\" title=\"可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作\"></a>可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IDefaultData</span> = <span class=\"keyword\">typeof</span> defaultData <span class=\"comment\">// &#123;name: string; age: number&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Ikeys</span> = keyof defaultData</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算\"><a href=\"#同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算\" class=\"headerlink\" title=\"同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算\"></a>同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IDefaultData</span> = <span class=\"keyword\">typeof</span> defaultData <span class=\"comment\">// &#123;name: string; age: number&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Ikeys</span> = keyof defaultData</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IData</span> = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">typeof</span> defaultData&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IList</span>  = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"title class_\">Pick</span>&lt;<span class=\"title class_\">IDefaultData</span>, <span class=\"string\">&#x27;name&#x27;</span>&gt; &amp; &#123;<span class=\"attr\">sex</span>: <span class=\"built_in\">number</span>&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: infer U; <span class=\"attr\">b</span>: infer U &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>&#125;&gt; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>&#125;&gt; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">c</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: symbol&#125;&gt; <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的推导</strong></li></ul>\n\n<h6 id=\"类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\"><a href=\"#类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\" class=\"headerlink\" title=\"类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\"></a>类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A1</span> <span class=\"comment\">//就当它是A1类型吧</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B1</span> <span class=\"comment\">// 就当它是B1类型吧</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = <span class=\"title class_\">Record</span>&lt;keyof <span class=\"title class_\">Foo1</span>, <span class=\"title class_\">Foo</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\"><a href=\"#而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\" class=\"headerlink\" title=\"而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\"></a>而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Parameters</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the parameters of a constructor function type in a tuple</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ConstructorParameters</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the return type of a function type</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ReturnType</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的条件语句</strong></li></ul>\n\n<h6 id=\"这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推\"><a href=\"#这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推\" class=\"headerlink\" title=\"这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推\"></a>这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Lengthwise</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">Lengthwise</span>&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// ok👌， arg 受Lengthwise约束，因此lenght是有的</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> | <span class=\"number\">2</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> ? <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;N&#125;</span>`</span> : <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过extends的约束功能给类型做一个三元表达的条件语句运算`</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的循环遍历</strong></li></ul>\n\n<p>既然是可以编程的，那就不可以缺少循环遍历的语句了。ts的类型也是可以通过[in]对类型进行循环遍历的。同样的，这只能在type中使用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: symbol;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: B; b: B; c: B; d: B&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125; <span class=\"comment\">// error,别问为什么不可以，语言就是这样</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\"><a href=\"#甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\" class=\"headerlink\" title=\"甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\"></a>甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: symbol;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = &#123;</span><br><span class=\"line\">    [ <span class=\"string\">`get<span class=\"subst\">$&#123;k&#125;</span>`</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;geta: B; getb: B; getc: B; getd: B&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"同样，作为\"><a href=\"#同样，作为\" class=\"headerlink\" title=\"同样，作为\"></a>同样，作为</h6><ul><li><strong>静态数据的类型</strong></li></ul>\n\n<h6 id=\"说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时\"><a href=\"#说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时\" class=\"headerlink\" title=\"说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时\"></a>说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>  = &#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">mode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\"><a href=\"#这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\" class=\"headerlink\" title=\"这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\"></a>这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(status === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mode === <span class=\"string\">&#x27;xxx&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试\"><a href=\"#这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试\" class=\"headerlink\" title=\"这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试\"></a>这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(status === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mode === <span class=\"string\">&#x27;xxx&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\"><a href=\"#如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\" class=\"headerlink\" title=\"如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\"></a>如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">IStatus</span> &#123;</span><br><span class=\"line\">    off,</span><br><span class=\"line\">    on</span><br><span class=\"line\">&#125; <span class=\"comment\">// &#123;off: 0, on: 1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>  = &#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: <span class=\"title class_\">Istatus</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 在之后的过程中都可以使用这个IStatus枚举</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const\"><a href=\"#通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const\" class=\"headerlink\" title=\"通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const\"></a>通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>] </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> arr <span class=\"comment\">// string[]</span></span><br><span class=\"line\"><span class=\"comment\">// 这个时候ts的反推类型就是string[]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> arr <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 这个时候ts的反推类型就是只读熟悉了，它可以用来弥补readonly的一些缺陷</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>动态类型的定义</strong></li></ul>\n\n<h6 id=\"是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\"><a href=\"#是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\" class=\"headerlink\" title=\"是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\"></a>是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &lt;T <span class=\"keyword\">extends</span> &#123;<span class=\"attr\">type</span>: <span class=\"string\">&#x27;a&#x27;</span>|<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"attr\">val</span>: <span class=\"built_in\">any</span>&#125;&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (arg.<span class=\"property\">type</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>: ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>: ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.<span class=\"property\">val</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: T</span><br><span class=\"line\">    <span class=\"attr\">b</span>: U</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\">(<span class=\"params\">a: T</span>) =&gt;</span> <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起\"><a href=\"#类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起\" class=\"headerlink\" title=\"类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起\"></a>类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">ProSchema</span>&lt;T = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, unknown&gt;, <span class=\"title class_\">Extra</span> = unknown, V = <span class=\"title class_\">ProSchemaComponentTypes</span>, <span class=\"title class_\">ValueType</span> = <span class=\"string\">&#x27;text&#x27;</span>&gt; = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@name</span> 确定这个列的唯一值 */</span></span><br><span class=\"line\">    key?: <span class=\"title class_\">React</span>.<span class=\"property\">ReactText</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 支持一个数字，[a,b] 会转化为 obj.a.b</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@name</span> 与实体映射的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    dataIndex?: keyof T;</span><br><span class=\"line\"></span><br><span class=\"line\">    render?: <span class=\"function\">(<span class=\"params\">dom: React.ReactNode, entity: T, index: <span class=\"built_in\">number</span>, action: ProCoreActionType, schema: ProSchema&lt;T, Extra&gt; &amp; &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        isEditable?: <span class=\"built_in\">boolean</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">type</span>: V;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    &#125;</span>) =&gt;</span> <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\"><a href=\"#处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\" class=\"headerlink\" title=\"处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\"></a>处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用</h6>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础知识概述\"><a href=\"#基础知识概述\" class=\"headerlink\" title=\"基础知识概述\"></a>基础知识概述</h2><p>伴随着ts4.3的发布，ts4.4也已经处于beta阶段了，ts成为了一个前端规范的趋势，随之vue、react和其他的plugin都开始了使用ts进行编写，ts已经成为了一个前端开发者所必需熟悉的一个东西。能否写出准确的ts类型也成为了一段代码的质量的评判条件之一。</p>\n<p> ts类型并不是只能有类型定义，然后给逻辑代码用这么简单。也并不是说代码懂得了一个any这样的全能类型，然后就到处使用any，只关心逻辑代码这块（能跑就行！！！！）。</p>\n<h2>1、是开发和维护过程中的工具</h2>\n\n<p>对于ts类型，他也是有自己的编程逻辑的。对于它，我们可以将它理解成一个我们项目开发与维护的工具，这个取决于我们对这个工具的了解程度和利用的程度，利用的好，它是规范我们的逻辑代码的一大利器，代码中的变量便会在明确的类型指引下快速且高效的开发。</p>\n<ul><li><strong>约束某一块代码的具体功能</strong></li></ul>\n\n<p>比如说在一个函数中，我们因为有了一个函数的约束，我们可以很明确的知道这个段逻辑块要完成的是一个什么样的功能，不得不说的是，很多人觉得ts是个累赘，那就是很多人都是先写逻辑，后写类型的，就是一种差不多的想法，代码能跑就行，最后只能写成了anyscript。 比如说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">arg</span>: A): <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们便能知道这个函数是一个要将A类型的变量处理处理成B类型的函数，这段代码有这样的作用就通过类型就可以显而易见了，当然前提是A和B的类型是明确的，不能写一个any，Object草草了事，当然在返回类型是也要尽量的准确点，比如说，有的时候为了一个求一个逻辑代码写的顺畅，盲目的让类型迎合变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">a</span>: A): <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"function\"><span class=\"params\">boolean</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = (<span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">object</span> | <span class=\"built_in\">boolean</span>): <span class=\"function\"><span class=\"params\">B</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的做法在ts编程的时候是不可取（不建议）的，其实在纯js中也是不建议这样的，这样失去了逻辑快单一功能的原则，会让后续的对它的维护显得特别的困难，在之后的调试过程中也会显得格外的困难。</p>\n<p>可能，我们会真的碰到这个函数逻辑就是要这样的耦合，那么我们不妨试试另一种类型声明的方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: A, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型A时，那么b的类型为string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: B, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型B时，那么b的类型为number</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> foo &#123;(<span class=\"attr\">a</span>: C, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): D&#125; <span class=\"comment\">// 参数a为类型C时，那么b的类型为number，且函数会有返回值D。</span></span><br></pre></td></tr></table></figure>\n\n<p>这三个都是给一个函数声明类型，然后可以很有效的做到逻辑耦合但是类型不耦合，同时也对函数的调用起到了类型校验的作用，不再是像以前写着一个联合类型，让人调用函数的时候觉得这个类型有点傻乎乎的样子，什么也不懂。</p>\n<p>这样的方式可以在很大的程度上，让函数的调用变得轻松，不至于让写出的东西让别人无法调用或者类型靠as去断言。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  (<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 参数a为类型string时，那么b的类型为string</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;(<span class=\"attr\">a</span>: <span class=\"built_in\">boolean</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>&#125; <span class=\"comment\">// 参数a为类型boolean时，那么b的类型为number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">foo</span>: <span class=\"title class_\">Foo</span> = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span>, b: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"number\">2</span>); <span class=\"comment\">// error,a为string类型时，b参数的类型为string</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">false</span>, <span class=\"number\">2</span>); <span class=\"comment\">// ok👌</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">true</span>, <span class=\"string\">&#x27;2&#x27;</span>) <span class=\"comment\">// error,第一个参数为boolean时，第二个参数必须为数字</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\"><a href=\"#注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\" class=\"headerlink\" title=\"注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别\"></a>注：这样声明的类型只能用interface，原因可以见下文的interface、type和class的区别</h6><p> 对于函数的逻辑块的类型声明可以这样，同理，组件中我们也可以做到。 其实组件中特别是想要复用性高一点的组件，一般都不会太建议太高的耦合度了，但是，方法也是有的了。</p>\n<p>在react中，如果是函数式组件，我们可以跟上面说的函数定义一样的去做</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IProps</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A1</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IProps</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A2</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ComponentA</span>: <span class=\"title class_\">React</span>.<span class=\"property\">FC</span>&lt;<span class=\"title class_\">IProps</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>同样，这样的耦合度对于这个组件的编写还是不太好的，但是很大程度上可以简化组件的调用，让别人可以更好的去调用它。 在class组件中，这样的做法会显得更加简便</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ComponentA</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;....&#125;</span><br><span class=\"line\">    <span class=\"title function_\">func</span>(): A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ComponentA</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;....&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComponentA</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;.....&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (....)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子对组件的编写过程起到的作用还是比较小的，但是对于组件的调用却有很大的意义，它可以查出组件错误的调用方式。</p>\n<ul><li><strong>约束静态数据</strong></li></ul>\n\n<p>作为工具，说白了就是没有它也一样，照样可以做出我想要的东西。但是ts能够一直发展过来，能够受到这么多的前端开发者的青睐自有它的原因。它确实是可以很好的去约束我们的代码，约束我们开发过程中所制造出的各种数据，这个也是取决于，自己对ts的理解程度的。 比如说我们在定义如下数据的类型时</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> schedule = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;01:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">   <span class=\"comment\">// ..... 省略，每隔30一个</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;12:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;12:30&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;13:00&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;13:30&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;22:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;23:00&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;23:30&#x27;</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在只知道interface，type的时候会一项一项的列出来</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:00&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;00:30&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"string\">&#x27;01:00&#x27;</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">   <span class=\"comment\">// ..... 省略，每隔30一个</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后再深入，知道了[in]，然后又会觉得，类型不过如此，会直接在写出</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后，更加深入的去知道了自带的工具类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ISchedule</span> = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显，对ts的使用程度就可以体现出来了，写法的不同，ts发挥的作用也都是不同的。</p>\n<p> 后面两种的写法很明显只是为了规避eslint的报错而写的类型的，定义太宽泛，这个时候如果是前端自己写类型定义可以使用类型的模板字符串</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> N = <span class=\"number\">1</span> | <span class=\"number\">2</span> | <span class=\"number\">3</span> | <span class=\"number\">4</span> | <span class=\"number\">5</span> | <span class=\"number\">6</span> | <span class=\"number\">7</span> | <span class=\"number\">8</span> | <span class=\"number\">9</span> | <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Time</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> | <span class=\"number\">2</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> ? <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;N&#125;</span>`</span> : <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">CheckEnum</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = <span class=\"title class_\">Record</span>&lt;<span class=\"string\">`<span class=\"subst\">$&#123;Time&lt;<span class=\"number\">0</span> | <span class=\"number\">1</span>&gt; | Time&lt;<span class=\"number\">2</span>&gt;&#125;</span>:<span class=\"subst\">$&#123;<span class=\"string\">&#x27;00&#x27;</span> | <span class=\"string\">&#x27;30&#x27;</span>&#125;</span>`</span>, <span class=\"title class_\">CheckEnum</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>模板字符串，它集成了[in]语法糖，让所有的可能类型自由组合，可以自动对所有的情况做一次遍历。 当然这样写只是为了提示一下ts的新特性中还有类型模板字符串，但是也可以看得出，ts的类型也越来越完善，可以让类型定义的越来越精确。有了这个模板字符串，很多的以前我们就写一个string的类型，我们都可以给定一个更加精确的定义，来保证我们的类型的准确性 比如说，我们给request定义url的时候我们就可以不写string，完全可以定义一个独有的IUrl类型，来规范url的编写。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IUrl</span> = <span class=\"string\">`/<span class=\"subst\">$&#123;<span class=\"built_in\">string</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> request = &lt;R&gt;<span class=\"function\">(<span class=\"params\">url: IUrl, options</span>) =&gt;</span> <span class=\"title class_\">Promise</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以避免犯前面忘了加 &#x2F; 这样的低级错误。 此外，类型模版字符串甚至可以用于校验电话号码，时间格式等字符串类型的数据，预防静态数据认为输入是校验太少而出现的错误。</p>\n<ul><li><strong>类型的断言</strong></li></ul>\n\n<p>其实ts作为工具，它和eslint的功能差不多，都是一个规范代码书写，可快发提效的手段。同时也会遇到一些ts无法准确做出判断的时候，毕竟ts是不参与逻辑代码的计算的，应该说，是不支持解耦之后的代码的类型运算。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;b&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: Foo1 | Foo2</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arg.<span class=\"property\">type</span> === <span class=\"string\">&#x27;a&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// arg is Foo1</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arg.<span class=\"property\">type</span> === <span class=\"string\">&#x27;b&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// arg is F002</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种前后耦合的情况下类型还是可以会能有自己的推导的，具体的，可以去看类型的合成与拆分，这也是在某个函数一定要耦合的时候建议的做法。</p>\n<h6 id=\"好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\"><a href=\"#好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\" class=\"headerlink\" title=\"好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动\"></a>好了以上的还是题外话，想提醒一下，是不是类型的联合都还搞不清楚。对于一些情况，比如说我们在一些dialog中，我们有时候会习惯用一个对象来驱动弹窗的显隐。让弹窗的显隐通过是否有数据驱动</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Dialog</span> visible=&#123;!!data&#125; close=&#123;data.<span class=\"property\">close</span>&#125;&gt; <span class=\"comment\">// error, data可能为undefined</span></span><br><span class=\"line\"> <span class=\"comment\">// some thing</span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下就难免会给data定义undefined的联合类型的了，到了一些方法中，这个主要是因为数据与视图解耦了，ts就会提醒你某个参数有可能为undefined，但是为undefined的时候数据都是不执行的，其实前面做一个非空检验也没什么大不了的，但是这个时候就看的出ts就比较傻了，此时我们的断言就可以用上了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Dialog</span> visible=&#123;!!data&#125; close=&#123;data!.<span class=\"property\">close</span>&#125;&gt; <span class=\"comment\">// ok, 这里可以用一个非空断言</span></span><br><span class=\"line\"> <span class=\"comment\">// some thing</span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Dialog</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>大部分的时候非空断言( ! )，我们基本上就够用了，可以解决大部分类型推导不过来的问题。</p>\n<p>但是还有很多时候，ts的使用程度不同的人会出现不一样的情况，有的人对类型的定义严格，有的人定义的宽松，为什么会这样可以看前面的概述。但是问题还是要解决的，我们这个时候如果真的非常肯定不会出问题，那么我们不妨试试as断言。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> ｜ <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;b&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: Foo2</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a) <span class=\"comment\">// error, Foo1类型不能给Foo2类型！</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a <span class=\"keyword\">as</span> <span class=\"title class_\">Foo2</span>) <span class=\"comment\">//ok，Foo2类型只是比Foo1类型更小，此处的断言可以告诉ts，我比你更清楚这个数据</span></span><br></pre></td></tr></table></figure>\n\n<p>从这个小例子中我们可以看出，断言对很多类型逃避主义的人其实也是一个非常大的福音，类型定义的时候宽泛就好了，衔接不上的时候直接as unknown as …、as any as …。如果有这种的行为，我也只能说，干的漂亮！ts技术又有了一点提升，只要代码能跑，还真让别人挑不出一点ts的毛病。 话说回来，还是好好的重视类型报错、严格的定义类型吧，如果真的是有非要有耦合的情况，可以看看上面本节的第一点说的方法吧。ts要不了多少时间的，真的可以避免错误，还有减少很多找bug的时间。</p>\n<ul><li><strong>全局类型声明</strong></li></ul>\n\n<p>应该很多人想过一个问题，为什么我们可以不需要引入，就可以用Record、Omit、Partail这样的工具类型。还有就是，我们自己开发过程中其实也写出了很多的好用的类型，有的是可以完全脱离某个项目，直接到处都可以用的，比如说我们Omit的源码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Omit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\"><a href=\"#它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\" class=\"headerlink\" title=\"它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit\"></a>它的第二个参数受的是any约束，虽然也有它的原因，但是我们完全可以自己再写一个MyOmit</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样就可以使得MyOmit更符合我们的需求\"><a href=\"#这样就可以使得MyOmit更符合我们的需求\" class=\"headerlink\" title=\"这样就可以使得MyOmit更符合我们的需求\"></a>这样就可以使得MyOmit更符合我们的需求</h6><h6 id=\"下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\"><a href=\"#下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\" class=\"headerlink\" title=\"下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？\"></a>下面的问题来了，如果我们只是这样的定义一下，别的地方想使用每次都得要去import，但是这个东西本来就是开发的时候稍微用一样，打包的时候都是去掉的。那么有什么办法可以别的地方直接用就好了？？</h6><h6 id=\"其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了\"><a href=\"#其实这个也很简单，只需要在根目录下定义一个-d-ts，文件就好了\" class=\"headerlink\" title=\"其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了\"></a>其实这个也很简单，只需要在根目录下定义一个.d.ts，文件就好了</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = <span class=\"title class_\">Pick</span>&lt;T, <span class=\"title class_\">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这样就好了，就可以在整个项目中使用了。</p>\n<p>如果你以为这一点就这么完了，那你想的肯定是太简单了，另外拓展一下，其实类型也是可以改写的😂😂。</p>\n<p>比如说，在使用Object.entries的时候，通过lib.es2017.d.ts中的源码可以看到，entries的类型定义还是有点不太好，不太适合日常的ts类型开发。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns an array of key/values of the enumerable properties of an object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">entries&lt;T&gt;(<span class=\"attr\">o</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: T &#125; | <span class=\"title class_\">ArrayLike</span>&lt;T&gt;): [<span class=\"built_in\">string</span>, T][];</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，我们就可以考虑一下改写它的类型，当然不是去修改编辑器的代码，别想太多。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">  entries&lt;T&gt;(<span class=\"attr\">obj</span>: T): [keyof T, T[keyof T]][];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2>2、是一个具有编程思想的语言</h2>\n\n<h6 id=\"上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\"><a href=\"#上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\" class=\"headerlink\" title=\"上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利\"></a>上一节中我们从typescript是一个规范开发的工具入手，讲述了ts可以有的几大功能。那么这一节，就讲述一下typescript其实也是有一定的编程思想的。它也是有自己的变量声明、条件语句、循环语句、作用域的，当你习惯了这个编程思想之后，就能够更加深刻的感受到ts所带来的便利</h6><ul><li><strong>interface、type、class的区别</strong></li></ul>\n\n<h6 id=\"很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别\"><a href=\"#很多人对interface、type的理解仅仅只是一个声明类型方式的区别。-但是事实上，它就是类型定义的一个区别。-只不过，有以下几点的区别\" class=\"headerlink\" title=\"很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别\"></a>很多人对interface、type的理解仅仅只是一个声明类型方式的区别。 但是事实上，它就是类型定义的一个区别。 只不过，有以下几点的区别</h6><h6 id=\"1、type，class定义的类型不可以重复，interface定义的类型可以重复\"><a href=\"#1、type，class定义的类型不可以重复，interface定义的类型可以重复\" class=\"headerlink\" title=\"1、type，class定义的类型不可以重复，interface定义的类型可以重复\"></a>1、type，class定义的类型不可以重复，interface定义的类型可以重复</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Record</span> = &#123;...&#125; <span class=\"comment\">// error, Record已经被定义过</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; <span class=\"comment\">// ok👌，interface 定义的类型可以重复定义，重新给Object的一些原型方法写类型</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以\"><a href=\"#这就是在上节中所讲的类型可以被重写的另一个知识点。-2、type声明的对象可以使用-in-，interface，class的不可以\" class=\"headerlink\" title=\"这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以\"></a>这就是在上节中所讲的类型可以被重写的另一个知识点。 2、type声明的对象可以使用[in]，interface，class的不可以</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Keys</span> = <span class=\"string\">&quot;小王&quot;</span> | <span class=\"string\">&quot;小文&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> X = &#123;</span><br><span class=\"line\">  [key <span class=\"keyword\">in</span> <span class=\"title class_\">Keys</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">test</span>: X = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;小王&#x27;</span>: <span class=\"string\">&#x27;肌肉男&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;小文&#x27;</span>: <span class=\"string\">&#x27;也是肌肉男&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> XX &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keys]: <span class=\"built_in\">string</span> <span class=\"comment\">// error!!!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型\"><a href=\"#3、interface，class使用extends、implements组合类型，type则可以通过-amp-符号组合、合并类型\" class=\"headerlink\" title=\"3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型\"></a>3、interface，class使用extends、implements组合类型，type则可以通过&amp;, |符号组合、合并类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animals1</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animals2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animals1</span>, <span class=\"title class_\">Animals2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> = <span class=\"title class_\">Animals1</span> &amp; <span class=\"title class_\">Animals2</span> &amp; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\"><a href=\"#4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\" class=\"headerlink\" title=\"4、interface定义的类型可以被改写，type、class定义的类型不可以被改写\"></a>4、interface定义的类型可以被改写，type、class定义的类型不可以被改写</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">aa</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;aa: string, ...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">Foo</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">aa</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;aa: number; ...&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\"><a href=\"#5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\" class=\"headerlink\" title=\"5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以\"></a>5、type可以使用typeof、keyof、infer去反推类型，interface、class不可以</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> foo <span class=\"comment\">//&#123; a: string, b: 2, c: boolean &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从以上的几点区别可以看出，类型的定义上，interface和class更像是给ecmascript增加了接口的概念，让类型与代码可以耦合，真正的将js变成了强类型语言（当然总是联合类型就另说了，基本上不会在意这么多了，基本上就不会管类型声明上的区别了）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal1</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal1</span>, <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// interface 可以使用extends集成</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal1</span>, <span class=\"title class_\">Animal2</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// 也可以使用class的extends和implements进行继承</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作\"><a href=\"#可以看出来使用的还是java里面的那一套。-之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用-in-等对类型各种各样的推导操作\" class=\"headerlink\" title=\"可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作\"></a>可以看出来使用的还是java里面的那一套。 之后的type的类型定义，便又是另一个编程思想了，它就是一个类型编程的思想了。它可以使用typeof，keyof，infer等各种类型推导。同时可以使用[in]等对类型各种各样的推导操作</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IDefaultData</span> = <span class=\"keyword\">typeof</span> defaultData <span class=\"comment\">// &#123;name: string; age: number&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Ikeys</span> = keyof defaultData</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算\"><a href=\"#同时也可以开始有了通过各种工具类型（有自带的也有自己写的-），对类型进行各种运算\" class=\"headerlink\" title=\"同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算\"></a>同时也可以开始有了通过各种工具类型（有自带的也有自己写的 ），对类型进行各种运算</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defaultData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IDefaultData</span> = <span class=\"keyword\">typeof</span> defaultData <span class=\"comment\">// &#123;name: string; age: number&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Ikeys</span> = keyof defaultData</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IData</span> = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">typeof</span> defaultData&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">IList</span>  = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, <span class=\"title class_\">Pick</span>&lt;<span class=\"title class_\">IDefaultData</span>, <span class=\"string\">&#x27;name&#x27;</span>&gt; &amp; &#123;<span class=\"attr\">sex</span>: <span class=\"built_in\">number</span>&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: infer U; <span class=\"attr\">b</span>: infer U &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>&#125;&gt; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>&#125;&gt; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">Foo</span>&lt;&#123;<span class=\"attr\">a</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">c</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: symbol&#125;&gt; <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的推导</strong></li></ul>\n\n<h6 id=\"类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\"><a href=\"#类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。-不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\" class=\"headerlink\" title=\"类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型\"></a>类型的推导那就是比较考验对类型够不够理解了，主要涉及到的ts知识点就为typeof、keyof、infer。 不过值得说的就是infer对于业务代码中的类型使用还是没那么多的。用的最多的还是typeof和keyof，它可以让人更快速的去得到想要的类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"variable constant_\">A1</span> <span class=\"comment\">//就当它是A1类型吧</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"variable constant_\">B1</span> <span class=\"comment\">// 就当它是B1类型吧</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo2</span> = <span class=\"title class_\">Record</span>&lt;keyof <span class=\"title class_\">Foo1</span>, <span class=\"title class_\">Foo</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\"><a href=\"#而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\" class=\"headerlink\" title=\"而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型\"></a>而对于infer，我们很多时候可以用它来制作工具类型，我们这个时候是可以参考Parammeters、ReturnType等工具类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Parameters</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the parameters of a constructor function type in a tuple</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ConstructorParameters</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">new</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain the return type of a function type</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ReturnType</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的条件语句</strong></li></ul>\n\n<h6 id=\"这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推\"><a href=\"#这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承-或许有的人的理解仅限于此-。同时可以有一个约束的功能，其实很像继承的反推\" class=\"headerlink\" title=\"这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推\"></a>这个又是一个关于extends的作用了，extends它不仅可以在interface上可以使用继承(或许有的人的理解仅限于此)。同时可以有一个约束的功能，其实很像继承的反推</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Lengthwise</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">Lengthwise</span>&gt;(<span class=\"attr\">arg</span>: T): T &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// ok👌， arg 受Lengthwise约束，因此lenght是有的</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> | <span class=\"number\">2</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"number\">0</span> | <span class=\"number\">1</span> ? <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;N&#125;</span>`</span> : <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span><span class=\"subst\">$&#123;<span class=\"number\">0</span>|<span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>&#125;</span>`</span></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过extends的约束功能给类型做一个三元表达的条件语句运算`</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>类型的循环遍历</strong></li></ul>\n\n<p>既然是可以编程的，那就不可以缺少循环遍历的语句了。ts的类型也是可以通过[in]对类型进行循环遍历的。同样的，这只能在type中使用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: symbol;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: B; b: B; c: B; d: B&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">    [k <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125; <span class=\"comment\">// error,别问为什么不可以，语言就是这样</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\"><a href=\"#甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\" class=\"headerlink\" title=\"甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型\"></a>甚至乎，我们还可以使用类型模版字符串，快速的写出更加标准的类型</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: symbol;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = &#123;</span><br><span class=\"line\">    [ <span class=\"string\">`get<span class=\"subst\">$&#123;k&#125;</span>`</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Foo</span>]: B;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;geta: B; getb: B; getc: B; getd: B&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"同样，作为\"><a href=\"#同样，作为\" class=\"headerlink\" title=\"同样，作为\"></a>同样，作为</h6><ul><li><strong>静态数据的类型</strong></li></ul>\n\n<h6 id=\"说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时\"><a href=\"#说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍-比如说，我们在定义一个mode，或者status时\" class=\"headerlink\" title=\"说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时\"></a>说到这个，我们就不得不说的了，很多时候，我们写一个string，number其实也算是一个类型的敷衍 比如说，我们在定义一个mode，或者status时</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>  = &#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">mode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\"><a href=\"#这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\" class=\"headerlink\" title=\"这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样\"></a>这样的类型定义，其实很明显也是在逃避的，毕竟后面的status或者mode也有可能是要用的。后面的代码很有可能就会这样</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(status === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mode === <span class=\"string\">&#x27;xxx&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试\"><a href=\"#这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。-其实对于这种静态的类型，建议是不应该用个number和string的。-对于前端自产自销的mode或者status，不妨试试\" class=\"headerlink\" title=\"这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试\"></a>这样就是让后面的维护者风中凌乱了，很不利于维护，同时那个number和string也很容易写错。 其实对于这种静态的类型，建议是不应该用个number和string的。 对于前端自产自销的mode或者status，不妨试试</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(status === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mode === <span class=\"string\">&#x27;xxx&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\"><a href=\"#如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\" class=\"headerlink\" title=\"如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了\"></a>如果是对于后端返回的而且要用到的，这个时候就可以使用枚举了</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">IStatus</span> &#123;</span><br><span class=\"line\">    off,</span><br><span class=\"line\">    on</span><br><span class=\"line\">&#125; <span class=\"comment\">// &#123;off: 0, on: 1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>  = &#123;</span><br><span class=\"line\">    <span class=\"attr\">status</span>: <span class=\"title class_\">Istatus</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 在之后的过程中都可以使用这个IStatus枚举</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const\"><a href=\"#通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了-对于静态的数据，可以做一点拓展知识，那就是as-const\" class=\"headerlink\" title=\"通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const\"></a>通过这个就不得不说一下了，其实enum与相似，它既可以参与逻辑，也可以参与类型。在类型中它可以表示一个基本类型。在逻辑中，它就可以充当出一个constant的作用了 对于静态的数据，可以做一点拓展知识，那就是as const</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>] </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> arr <span class=\"comment\">// string[]</span></span><br><span class=\"line\"><span class=\"comment\">// 这个时候ts的反推类型就是string[]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> arr <span class=\"comment\">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// 这个时候ts的反推类型就是只读熟悉了，它可以用来弥补readonly的一些缺陷</span></span><br></pre></td></tr></table></figure>\n\n<ul><li><strong>动态类型的定义</strong></li></ul>\n\n<h6 id=\"是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\"><a href=\"#是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。-逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\" class=\"headerlink\" title=\"是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块\"></a>是编程，那么就得有变量的声明，和数据的自顶向下的数据流，ts中也是一样的，这个东西便是泛型了。有了它，就可以正式的将类型带入了编程的行列。 逻辑代码上泛型可以跟函数跟类进行耦合，去写出一个更加可用的模块</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &lt;T <span class=\"keyword\">extends</span> &#123;<span class=\"attr\">type</span>: <span class=\"string\">&#x27;a&#x27;</span>|<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"attr\">val</span>: <span class=\"built_in\">any</span>&#125;&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (arg.<span class=\"property\">type</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>: ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>: ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.<span class=\"property\">val</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span>&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: T</span><br><span class=\"line\">    <span class=\"attr\">b</span>: U</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"function\">(<span class=\"params\">a: T</span>) =&gt;</span> <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起\"><a href=\"#类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率-我们可以拿我们熟知的protable的类型定义说起\" class=\"headerlink\" title=\"类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起\"></a>类型编程上我们可以通过泛型，写出各种好用的工具类型，提升我们的开发效率 我们可以拿我们熟知的protable的类型定义说起</h6><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">ProSchema</span>&lt;T = <span class=\"title class_\">Record</span>&lt;<span class=\"built_in\">string</span>, unknown&gt;, <span class=\"title class_\">Extra</span> = unknown, V = <span class=\"title class_\">ProSchemaComponentTypes</span>, <span class=\"title class_\">ValueType</span> = <span class=\"string\">&#x27;text&#x27;</span>&gt; = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@name</span> 确定这个列的唯一值 */</span></span><br><span class=\"line\">    key?: <span class=\"title class_\">React</span>.<span class=\"property\">ReactText</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 支持一个数字，[a,b] 会转化为 obj.a.b</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@name</span> 与实体映射的key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    dataIndex?: keyof T;</span><br><span class=\"line\"></span><br><span class=\"line\">    render?: <span class=\"function\">(<span class=\"params\">dom: React.ReactNode, entity: T, index: <span class=\"built_in\">number</span>, action: ProCoreActionType, schema: ProSchema&lt;T, Extra&gt; &amp; &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        isEditable?: <span class=\"built_in\">boolean</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">type</span>: V;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    &#125;</span>) =&gt;</span> <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\"><a href=\"#处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\" class=\"headerlink\" title=\"处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用\"></a>处于一个Protable的复杂度，这里只截取了其中的一小段。可以看到我们会把传入的一行的类型到做参数T传进来，在dataIndex和render这里直接把T当作一个类型使用</h6>"},{"title":"你不知道的TypeScript","date":"2022-03-06T07:14:33.000Z","description":"总结ts的类型层级、枚举、断言等相关知识，更加深入的了解typescript","_content":"\n# 基础概括\n\n## 1.1 枚举\n\n### 1.1.1 背景介绍\n\n维护别人的代码尤其是一些质量较差的代码时，我们常常会碰到以下这样的代码，这样的状态位在之后的开发中很容易混乱。\n\n```typescript\nconst handle = (status: number) => {\n    if (status === 2) {\n        // do something\n    }\n}\n\njson ={\n 'name':'zhangsan'\n 'email':'1234567@qq.com'\n}\n```\n\n所以说这个时候就需要有一个对象可以来将这些状态为做一个集中管理了。\n\n### 1.1.2 基础用法\n\nts中的枚举其他的高级语言的枚举不同的是，ts中的枚举成员的值可以是字符串/数字。\n\n```typescript\nenum NoYes {\n    no = 'no',\n    yes = 'yes',\n}\nenum NoYes {\n    no = 0,\n    yes = 1,\n}\n```\n\n此外，在ts的枚举中也可以使用数字的递增来定义枚举成员。\n\n```typescript\nenum NoYes {\n    no, // 0\n    yes, // 1\n}\n```\n\n但是，在定义数字型枚举作为类型时，便会出现一个松散型的类型检查，它会直接将这个枚举类型当作一个number类型。\n\n```typescript\nenum NoYes {\n    no,\n    yes,\n}\nconst foo = (sig: NoYes) => {\n    // do something...\n}\nfoo(11) // ok! 这个时候是不会报错的\n```\n\n因为这个特性，很容易的引起别人对公共模块乱传参对情况，比如说例子中我们无法对函数foo的入参做一个严格的检查。\n但是当枚举值是字符串时就不再有这个问题了。\n\n```typescript\nenum NoYes {\n    no = 'no',\n    yes = 'yes',\n}\nconst foo = (sig: NoYes) => {\n    // do something。。。\n}\nfoo('no') // error\nfoo(NoYes.no) // ok!\n\n```\n\n所以说，在很多的情况下都是建议采用字符串作为枚举值的，可以起到一个更好的约束作用。\n但是在涉及到与后端的交互的时候，也是没办法的，是数字就还是得用数字，如果说擅自将数字改成字符串的还是会引起一些不必要的麻烦的。遗憾的是，之后的ts版本，将不会再去更新会影响代码运行的内容，所以说对于数字枚举松散型的问题，在后期也是不会再去解决了。\n于是，我们也可以采用这种方法：\n\n```typescript\nenum NoYes {\n    no, // 0\n    yes, // 1\n}\nconst foo = (sig: keyof typeof NoYes) => {\n    // do something。。。\n}\nfoo(11) // error\nfoo('no') // ok!\n```\n\n相比于枚举类型的数字，字符串还是比较好理解的，同时对入参的格式限制也还是有比较准确的定义，可以很好的检查出存不存在乱传参的行为。\n\n1.1.3 运行时的枚举\n上文说到枚举是少数的会参与代码运行的ts的内容之一，因此枚举是会被编译成js代码的。\n以简单的NoYes枚举为例：\n\n```typescript\nenum NoYes {\n  No,\n  Yes,\n}\n```\n\nts将这个枚举编译为：\n\n```typescript\nvar NoYes;\n(function (NoYes) {\n  NoYes[NoYes[\"No\"] = 0] = \"No\";\n  NoYes[NoYes[\"Yes\"] = 1] = \"Yes\";\n})(NoYes || (NoYes = {}));\n```\n\n通过编译后的代码我们可以看出，枚举具有反向映射的功能，可以通过值反向获取到枚举成员。\n\n```typescript\nenum NoYes {\n  No,\n  Yes,\n}\nNoYes.yes // 1\nNoYes[NoYes.yes] // yes\n```\n\n为了减小代码运行时的负担，也有了一个常量枚举，让枚举只是参与开发过程，而不在参与js的运行过程。\n\n```typescript\nconst enum NoYes {\n  No,\n  Yes,\n}\n```\n\n以上的NoYes枚举在编译之后是会与类型一样被删除的，而在使用也会有区别。const枚举会失去反向映射的功能\n\n```typescript\nconst enum NoYes {\n  No,\n  Yes,\n}\nconst val1 = NoYes.yes // ok! val1 = 1\nconst val2 = NoYes[NoYes.yes] // error!  val2 = undefined\n```\n\n编译完之后的代码也会去掉enum的定义，引用的也直接给一个定值\n\n```typescript\nconst val1 = 1;\nconst val2 = undefined;\n```\n\n这样对于缩小打包后的代码体积起到了一定的作用，在开发的过程中可以根据实际情况去使用const枚举，同时这样对打包后的代码也可以起到一个更好的加密效果。\n\n### 1.1.4 对象枚举\n\n在没有ts的时候写js代码，我们对枚举的定义都会使用一个对象写出一个枚举\n\n```typescript\n// ./enmus.js\nexport const StatusEnum = {\n    off: 0,\n    on: 1\n}\n\nimport { StatusEnum } from './enums'\n\n// ...\nconst handle = (status) => {\n    if (status === StatusEnum.off){\n        // do something....\n    }\n}\n// ...\n```\n\n在ts项目中，这样的方式去定义枚举也不是不可以的，但是这时候我们可以去设置一个as const只读属性。\n\n```typescript\n// ./enmus.js\nexport const StatusEnum = {\n    off: 0,\n    on: 1\n} as const\n```\n\n对象枚举的优点：\n\n```markdown\n将旧的js代码改造成ts更加的方便\n可以对键值加计算逻辑\n枚举值可以是Symbol类型\n\n对象枚举的缺点\n无法反向映射\n对于枚举值的类型描述困难，透传的时候不好去描述类型（可以自己写一个ValueOf工具类型，但是有理解成本，如下代码）\n```\n\n```typescript\nexport const NoYes = {\n    yes: 1,\n    no: 0\n} as const\n```\n\n```typescript\n// 获取值\ndeclare type ValueOf<T> = T extends {[K in keyof T]: infer V } ? V : never;\nconst handle1 = (k: keyof typeof NoYes) => { // 通过keyof typeof约束类型，但是不好去透传\n    // do something...\n}\nconst handle2 = （v: ValueOf<typeof NoYes>) => { // 可以透传枚举值，但是ValueOf有理解成本\n    // do something...\n}\n```\n\n## 1.2 类型守卫\n\n### 1.2.1 类型的层级\n\n在前面提到了顶级类型的概念，在ts中，类型是有自己的层级的，当一个类型可以被一个类型约束时，那么这个这两个类型便构成了上下级的关系（这节我们就排除any，它是一个特殊的例子）。类型也只能在同级和下级到上级传递，他们也构成了一个单向的传递关系。这也就是任何类型都可以给unknown，never可以给任何类型的原因。\n\n```typescript\nconst foo = (arg: T1 | T2 | undefined) => {\n    // do something;\n}\nconst obj1: T1 = {\n//...\n};\nconst obj2: T2 = {\n//..\n}; \nlet obj3: T3\nfoo(undefined) // ok!!\nfoo(obj1); // ok!!\nfoo(obj2); // ok!!\nfoo(obj3); // ok!!\n```\n\n不过值得注意的是，在非基础类型内部，上下级的关系就是不一样的了。\n\n```typescript\ntype T1 = {\n  a: string,\n  b: number\n  c: boolean\n}\ntype T2 = {\n  a: string,\n  b: number\n}\n\nconst foo1 = (arg: T2) => {\n    // do something\n}\nconst obj1: T1 = {\n  a: 'aa',\n  b: 1,\n  c: true\n}\nfoo1(obj1)； // ok！！\n```\n\n但是，在开发过程中难免会遇到类型不小心被放大的情况，然后被ts提示有不严谨的地方。(这种时候可能又会有人骂骂咧咧的说ts不好了)\n在这个是时候其实需要对类型做一个守卫，从而再将类型进行收窄。\n\n### 1.2.2 类型收窄\n\n说起类型收窄，我们首先可以想到的在js中所拥有的\n\n```markdown\n类型判断：typeof；\n实例判断：instanceof；\n属性判断：in；\n字面量相等判断：==，===，!=，!==；\n```\n\n它们在代码书写的时候都将通过if else和switch起到一定的类型守卫的作用，ts也可以对所参与的变量起到一个类型收窄的作用。\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\ntype T2 = {\n  a: number;\n  b: number;\n  d: 'type2';\n}\nconst foo1 = (arg?: T1 | T2 | string) => {\n  if (!arg) return;\n  // arg is T1 | T2 | string\n  if (typeof arg === 'string') {\n      // arg is string\n  } else {\n      // arg is T1 | T2\n      if ('c' in arg) {\n        // arg is T1\n      }\n      if (arg.d === 'type1') {\n        // arg is T1\n      }\n      if (arg.d === 'type2') {\n          // arg is T2\n      }\n  }\n}\n```\n\n在后面的章节中会讲到，never是所有类型的子类型，所以说never是所有类型的下级类型。\n所以说我们可以这么理解\n\n```typescript\ntype T1 = {\n    a: string | never;\n    b: number | never;\n    c: boolean | never;\n} | never\ntype T2 = {\n    a: string | never;\n    b: number | never;\n    d: string | never;\n} | never\n```\n\n每一个已知类型都是会被ts联合一个never的子类型的，当然这个联合不是我们自己写上去的。\n所以说我们在使用if，switch做类型收窄的时候就会发现，当我们吧所有的已知类型都考虑完之后，编辑器就会出现一个never未知类型\n\n```typescript\ntype T1 = {\n    a: 'a' | 'b' | 'c';\n    // any other keys;\n}\nconst foo = (arg: T1) => {\n    switch(arg.a) {\n        case 'a': \n            // do something...\n            break;\n        case 'b':\n            // do something...\n            break;\n        case 'c':\n            // do something...\n            break;\n        default \n            // arg.a is never\n    }\n}\n```\n\n通过我们上面对never以及上下子类型的理解，知道了T1类型是会被ts给完整的写成\n\n```typescript\ntype T1 = {\n    a: 'a' | 'b' | 'c' ｜ never;\n    // any other keys;\n} | never;\n```\n\n在开发中我们可以用if else和switch将类型收窄，也可能会想到通过类型断言将类型收窄。\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\ntype T2 = {\n  a: number;\n  b: number;\n  d: 'type2';\n}\nconst  foo1 = ( arg: T1 | T2 ) => {\n    // do something....\n}\n\nlet t1: T1 | T2 | string | undefined\n// do something...\nfoo1(t1) // error!！ T1 | T2 | string | undefined类型不能给T1 | T2\nfoo1(t1 as T1) // ok\nfoo1(t1 as T2) // ok\nfoo1(t1 as T1 | T2) // ok\n```\n\n这种情况下很大的可能是一些个人原因没定义好类型，在更多的情况下我们遇到的是一个可能为空的情况，于是我们也可以使用非空断言\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\n\nlet t: T1 // t is T1 | undefined\n// do something...\nconst foo = (arg: T1) => {\n    // do something...\n}\nfoo(t) // error! t的值很有可能为undefined。\nfoo(t!) // ok! 通过非空断言（!）断言t不是undefined和null\n```\n\n不管怎样，断言收窄还是不建议乱去使用的，更加推荐的是使用is去做一个类型收窄\n\n```typescript\nconst projectType = <T>(\n    data: unknown,\n    cb: (arg: unknown) => boolean\n): data is T => {\n  return cb(data)\n}\n\ntype T1 = {\n    a: string;\n    b: number;\n}\ntype T2 = {\n    c: boolean;\n    d: number;\n}\nconst foo = (arg?: T1 | T2) => {\n    if (!arg) return;\n    // arg is T1 | T2\n    if (projectType<T1>(arg, (a) => !!(a as T1)?.a)) {\n        // arg is T1\n    } else {\n        // arg is T2\n    }\n}\n```\n\n使用is去做类型守卫，看似麻烦了很多。但是从逻辑层面去对数据进行了一个类型收窄，相比于断言，这样可以很大的降低运行时的风险。（当然那个判定逻辑不能随便去写）\n\n### 小结\n\n```markdown\n类型守卫的核心是将类型收窄，可以将类型收窄成它的子类型\n可以灵活的使用js中的相关内容对一个类型做相应的收窄\n断言只能在上下级类型断言！不可以在没有上下级关系的类型之间断言，相关的区别会在本文中的断言中做详细介绍。\n断言属于欺骗编译器的行为，并不会在运行过程中起作用，在开发中不可以盲目断言！更推荐于使用if else加is去做一个逻辑层的类型守卫。\n```\n\n## 1.3 any、unknown、never\n\n### 1.3.1 any、unknown、never对比\n\nts作为一个静态语言，与强类型还是有所区别的。强类型是将代码编译成另一种语言的代码的，但是静态语言还是逃脱不了是一个弱类型的本质，有很多时候还是可以逃避的。所以说很多时候我们会看到的是能有any，unknown，never这样的隐式类型。\n它们的区别如下：\nany属于顶级、底级类型，所有的类型都可以给any，any类型可以给其他任何类型；\nunknown属于顶级类型，所有的类型都可以给unknown，但是在unknown调用方法时必须要对unknown做存在的判断；\nnever属于底级类型，它可以给所有已知类型，但是已知类型不可以给never类型；\n\n### 1.3.2 any是top type和bottom type\n\n写过ts代码的人，对any可能是非常熟悉的一个东西了，毕竟any可以解决很多的问题。\n在ts的提案中，any属于顶级类型，任何类型都可以赋给它。\n\n```typescript\nconst handle (item: any) => {\n    // do something...\n}\n\nconst str: string = \"hello world!\"\nconst num: number = 100\nconst isYes = true\nhandle(str) // ok!!\nhandle(num) // ok!!\nhandle(isYes) // ok!!\n```\n\n同时any也是底级类型，它可以赋给任何类型\n\n```typescript\nconst a1: any\nconst str: string = a1; // ok!\nconst num: number = a1; // ok!\n```\n\n所以说，any的优点还是挺明显的，但是any肯定不是可以让你类型自由的工具。对于代码中还是要尽量的去写已知类型。\n\n### 1.3.3 unknown是顶级的类型\n\n在其他的很多文章中都说unknown和any很像或者类似，但是这个说法也不是那么准确。\nunknown在ts的提案中定义为了一个顶级的类型。任何类型都可以赋给unknown，在使用unknown的时候需要将类型收窄。\n\n```typescript\nconst foo = (arg: unknown) => {\n    arg.push() // error!!\n    if (typeof arg === 'array') {\n        arg.push() // ok\n    }\n}\n```\n\ntry catch 语句中的catch后面的error参数会是unknown，然后有的时候我们会碰到比较难处理的情况，我们这个时候也可以使用断言进行类型收窄。\n\n```typescript\ntry {\n  // do something...\n} catch (err) {\n  // err is unknown\n  if((err as Error )?.message === '...') {\n    const error = err as Error\n    // error is Error\n  }\n}\n```\n\n上面的收窄方式可能还是太机械性了，重复的代码写的太多，我们也可以使用is关键字对unknown进行类型收窄\n\n```typescript\n/**\n * 对数据进行类型守卫的函数\n * @param data 守卫的数据\n * @param cb 判断守卫的函数，把能够确定的逻辑写进来，返回true就是确定这个类型\n * @returns 第二个参数返回true为这个类型，否则不是\n */\nconst projectType = <T>(\n    data: unknown,\n    cb: (arg: unknown) => boolean\n): data is T => {\n  return cb(data)\n}\n\ntry {\n  // do something...\n} catch (err) {\n  // err is unknown\n  if(projectType<Error>(err, (e) => !!(e as Error)?.message)) {\n    // err is Error\n  }\n}\n```\n\n### 1.3.4 never是所有类型的子类型\n\n由上面的对比可知，never可以是所有类型的子类型，在有已知类型的时候，never就会直接合并入已知类型中，不再有never类型。\n\n```typescript\nconst T1: number | never // number\nconst T2: unknown | never // unknown\nconst T3: string | number | never // string | number\nconst T4: never //never\n```\n\n所以说never类型可以表示为一个无法推断出来的类型，这个在很多的工具类型特别是使用infer的类型中可以看到。表示的都是无法推断出想要得到的类型。\n\n```typescript\n// 是否为空类型\ntype NonNullable<T> = T extends null | undefined ? never : T;\n// 获取函数参数类型的元数组\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n\n// 取U中的非T部分\ntype Exclude<T, U> = T extends U ? never : T;\n// 取U中的T部分\ntype Extract<T, U> = T extends U ? T : never;\n```\n\n此外，never还可以表示的是未知类型，意思为它不属于任何一种类型，这种情况下在switch和if else语句中尤为明显，对这个的处理的也能体现出，逻辑代码是否能够考虑极端情况，对代码的稳定性的提高显得尤为重要。\n\n```typescript\nenum NoYes { no, yes }\nconst handleErr = (e: Error) => {\n    // do something;\n}\nconst foo = (type: NoYes) => {\n    switch(type) {\n        case NoYes.yes: \n            // do something....\n        break;\n        case NoYes.no:\n            // do something...\n        break;\n        default: \n        /* 这种case的时候就是一个never类型，\n         * 这种never类型可以给其他的任何类型\n        */\n            handleErr(type); // ok!\n    }\n}\n```\n\n### 小结\n\n```markdown\n介绍到这里，或许大家可以对any，unknown与never有一个了解，在使用的时候也有相应的几点建议：\n减少未知类型的出现，少写甚至不写any；\n对类型的声明要做到准确，避免隐式类型；\n对never类型能够做合理拦截；\n对于unknown类型能够做出合理的类型收窄；\n```\n\n## 1.4 联合undefined 与可选在实际使用过程中的区别\n\n### 1.4.1 对象中键值设置为undefined和没有它的区别\n\n由于js的灵活性，也是能够允许对象中的键值为null和undefined。但是设置为undefined的时候最重要的一点是可以被遍历到。\n\n```typescript\nconst obj = {a: 1, b: 2};\nobj.b = undefined;\nfor (const k in obj) {\n    console.log(k);\n}\n// a, b\n\nconst obj = {a: 1, b: 2};\n// @ts-ignore\ndelete obj.b\nfor (const k in obj) {\n    console.log(k);\n}\n// a\n```\n\n为了表示出对象中的缺别，我们就有了键值联合undefined和可选的区别了\n\n### 1.4.2 ts类型的undefined联合和可选\n\n许多人在写ts的时候很早的时候就会注意到那个可选值，然后有的时候也可会观察到有一些的组件库的类型是{k: string | undefined}类型。甚至还会疑惑为什么不是写 ?: (毕竟 ?: 字符少，写起来方便^_^！！)。\n这个地方就牵扯到ts类型的一个小细节了。\n\n```typescript\ntype T1 = {\n    a: number;\n    b: string;\n    c: boolean ｜ undefined;\n    d?: number;\n}\nconst obj1: T1 = { a: 1, b: '1', c: true } // ok\nconst obj2: T1 = { a: 1, b: '1', c: true, d: 2 } // ok\nconst obj3: T1 = { a: 1, b: '1', d: 2 } // error，缺少键值c\nconst obj4: T1 = { a: 1, b: '1', c: undefined, d: 2 } // ok\nconst obj5: T1 = { a: 1, b: '1', c: true, d: undefined } // ok\nconst obj6: T1 = { a: 1, b: '1', c: true, d: '2' } // error, d的类型不对\n```\n\n当一个类型的键使用可选声明时，这个键代表的就是可有可无了（有肯定是约定好的类型），但是设置为undefined联合时，这个键就必须得有了。\n而且在我们将键设置为可选时，我们可以对该键进行delete，依然以上面的obj对象为例\n\n```typescript\ndelete obj3.d // ok！！\ndelete obj5.c // error!!\n```\n\n### 小结\n\n```markdown\n开发过程中对非基础类型中的undefined属性定义要合理\n为了减少可选类型对维护的时候带来的误解，可以使用| undefined来代替可选\n```\n\n## 1.5 object、Object与{}\n\n### 1.5.1 基本类型\n\n在ts中，基本类型包括string、number、boolean、symbol、[]、enum、undefined、null、void、unknown、never、any等。详细可见：<https://juejin.cn/post/7006304933813157919>\n它们构成了ts的基本类型，由ts内部自己定义。\n\n### 1.5.2 非基本类型\n\n除了上述的基本类型外，其他的类型都为非基本类型。ts2.7版本中被提出object类型，表示ts中的非基本类型。在此之前，lib.d.ts中收录了Object类型来表示非基本类型。\n所以说，类似于以下类型，都称为非基本类型\n\n```typescript\ninterface T1 {\n  a: string;\n  b: number;\n  c: boolean;\n  // ...\n}\ninterface T2 {\n  a: number;\n  b: number;\n  d: 'type2';\n  // ...\n}\n```\n\n同时在ts的lib.d.ts中，我们也是可以看到有Object的声明的\n\n```typescript\n/**\n * Provides functionality common to all JavaScript objects.\n */\ndeclare var Object: ObjectConstructor;\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    // ...\n}\n```\n\nobject相当于就是将Object定义成一个基本类型。\nobject与Object的各有以下特点：\n\n```markdown\nobject是ts内部定义的基本类型，表示的是非基本类型，不可被重写；\nObject类型为lib.d.ts中声明的非基本类型，可以被改写\n```\n\n### 1.5.3 Object是所有的非基本类型的父类型\n\n所有的非基本类型中，都会继承Object类型。这个也是ts自身赋予的，不需要我们去写。我们在使用一个非基本类型的时候，是可以使用到hasOwnProperty、valueOf、length等原型属性的。\n\n```typescript\ninterface T1 {\n    a: string;\n    b: number;\n}\n\nconst p: T1 = {\n    a: 'a',\n    b: 1\n}\np.hasOwnProperty('a'); //ok! Object上有这个方法\n```\n\n### 小结\n\n```markdown\nobject是基本类型，它表示非基本类型Object\n不建议将变量类型直接声明为object或Object，除非真的只用object的原型属性\nObjectConstructor有一些方法类型定义不够准确，可以尝试去改写它\n```\n\n## 1.6 interface 和 type  自定义类型\n\n大家使用 typescript 总会使用到 interface 和 type,但是很少能够真正区分它俩，接下来介绍下他们之间的区别\n1、相同点\n\n- 都可以描述一个对象或者函数\n\n```typescript\n// interface定义对象\ninterface User {\n  name: string\n  age: number\n}\n\n// interface定义函数\ninterface SetUser {\n  (name: string, age: number): void;\n}\n\n// type定义对象\ntype User = {\n  name: string\n  age: number\n};\n\n// type定义函数\ntype SetUser = (name: string, age: number)=> void;\n```\n\n- 都允许拓展（extends）\ninterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\ninterface使用extends、implements组合类型 , type则可以通过&, |符号组合、合并类型。\n1 interface extends interface\n\n```typescript\ninterface Name { \n  name: string; \n}\n\ninterface User extends Name { \n  age: number; \n}\n```\n\n2. type extends type\n\n```typescript\ntype Name = { \n  name: string; \n}\n\ntype User = Name & { age: number  };\n\n```\n\n3. interface extends type\n\n```typescript\ntype Name = { \n  name: string; \n}\ninterface User extends Name { \n  age: number; \n}\n```\n\n4. type extends interface\n\n```typescript\ninterface Name { \n  name: string; \n}\ntype User = Name & {\n  age: number;\n}\n```\n\n2、不同点\n\n- type 可以声明基本类型别名，联合类型，元组等类型\n\n```typescript\n// 基本类型别名\ntype Name = string\n\n// 联合类型\ninterface Dog {\n    wong();\n}\ninterface Cat {\n    miao();\n}\n\ntype Pet = Dog | Cat\n\n// 具体定义数组每个位置的类型\ntype PetList = [Dog, Pet]\n\n- type 语句中还可以使用 typeof 获取实例的 类型进行赋值\n// 当你想获取一个变量的类型时，使用 typeof\nconst foo = {\n    a: 'a',\n    b: 2,\n    c: true\n}\ntype Foo = typeof foo //{ a: string, b: 2, c: boolean }\n```\n\n- interface 能够声明合并，也是interface 一个比较强大的地方，可以重复定义添加属性，type不行\n\n```typescript\ninterface User { \n    name: string \n    age: number \n} \ninterface User { sex: string } \n/* User 接口为 { name: string age: number sex: string } */\n```\n\n## 1.7  & 交叉类型\n\n在 TypeScript 中交叉类型是将多个类型合并为⼀个类型。通过 & 运算符可以将现有的多种类型叠加到 ⼀起成为⼀种类型，它包含了所需的所有类型的特性。\n\n```typescript\ntype X = { \n   x: number; \n}; \ntype Point = X & { y: number; }; // 定义point的类型：  合并X和y的类型\n\nlet point: Point = { \n    x: 1, \n    y: 1 \n}\n```\n\n- 同名基础类型属性的合并\n那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型 ⼜不⼀致，⽐如：\n\n```typescript\ninterface X { \n    c: string; \n    d: string; \n}\ninterface Y { \n    c: number; \n    e: string \n} \ntype XY = X & Y; \ntype YX = Y & X; \nlet p: XY; \nlet q: YX;\n```\n\n在上⾯的代码中，接⼝ X 和接⼝ Y 都含有⼀个相同的成员 c，但它们的类型不⼀致。对于这种情况，此 时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 string 或 number 类型呢？⽐如下⾯的例⼦：\n\n```typescript\np = { c: 6, d: \"d\", e: \"e\" }; // 接上面的示例\nq = { c: \"c\", d: \"d\", e: \"e\" };\n```\n\n为什么接⼝ X 和接⼝ Y 混⼊后，成员 c 的类型会变成 never 呢？这是因为混⼊后成员 c 的类型为\nstring & number ，即成员 c 的类型既可以是 string 类型⼜可以是 number 类型。很明显这种类型\n是不存在的，所以混⼊后成员 c 的类型为 never，因避免出现类似情况\n\n- 同名⾮基础类型属性的合并\n\n```typescript\ninterface D { d: boolean; }\ninterface E { e: string; }\ninterface F { f: number; }\ninterface A { x: D; }\ninterface B { x: E; }\ninterface C { x: F; }\ntype ABC = A & B & C;\nlet abc: ABC = {\n    x: {\n      d: true, e: 'semlinker', f: 666\n    }\n};\nconsole.log('abc:', abc);\n```\n\n由上图可知，在混⼊多个类型时，若存在相同的成员，且成员类型为⾮基本数据类型，那么是可以成功合并。\n\n## 1.8 Tuple 类型\n\n我们知道数组中元素的数据类型一般都是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。元组中允许存储不同类型的元素，元组可以作为参数传递给函数。\n\n- 声明一个元组mytuple，并初始化：\n\n```typescript\nlet mytuple: [number, string]\nvar mytuple = [10,\"Runoob\"];\n```\n\n- 访问元组\n\n```typescript\nconsole.log(mytuple[0]) // 10\nconsole.log(mytuple[1]) // Runoob\n```\n\n- 可选元组\n元组类型允许在元素类型后缀一个 ? 来说明元素是可选的：\n\n```typescript\nlet mytuple: [number, string?，boolean?]\nlet mytuple = [10,\"Runoob\",ture];\nlet mytuple1 = [10,\"Runoob\"];\nlet mytuple2 = [10,];\n```\n\n- 元组越界\n可以越界添加元素（不建议），但不可越界访问，有可选元素更不建议使用元组越界，因为可选元素一般都在最后\n\n```typescript\nlet mytuple: [number, string] = [10,\"Runoob\"];\nmytuple.push('hello world')\n\nconsole.log(mytuple) // [10, 'Runoob', 'hello world' ] \nconsole.log(list[2]) // Tuple type '[string, number]' of length '2' has no element at index '2'\n```\n\n- 命名元组类型\n命名元组类型适需要 TypeScript 4.0及以上版本才能使用，它极大的改善了我们的开发体验及效率，先来看一个例子:\n\n```typescript\ntype Address = [string, number]\nfunction setAddress(...args: Address) {\n  console.log(args)\n}\n```\n\n当我们这样定义函数入参后，在使用函数时，编辑器的智能提示只会提示我们参数类型，丢失了对参数含义的描述。\n\n为了改善这一点，我们可以通过命名元组类型，我们可以这样定义参数：\n\n```typescript\ntype Address = [streetName: string, streetNumber: number]\n\nfunction setAddress(...args: Address) {\n  console.log(args)\n}\n```\n\n这样，在调用函数时，我们的参数就获得了相应的语义，这使得代码更加容易维护。\n这两种⽅式看起来没有多⼤的区别，但对于第⼀种⽅式，我们没法设置第⼀个参数和第⼆个参数的名称。虽然这样对类型检查没有影响，但在元组位置上缺少标签，会使得它们难于使⽤。为了提⾼开发者使⽤元组的体验，TypeScript 4.0 ⽀持为元组类型设置标签\n\n- 典型应用 useState\n\n```typescript\nimport { useState } from 'react';\nconst [loading, setLoading] = useState<boolean>(false);\n```\n\n## 1.9 字符串模板类型\n\n### 1.9.1  基础语法\n\n它的语法和 es 里的字符串模板很相似，所以上手成本也很低，先看几个🌰：\n\n```typescript\ntype EventName<T extends string> = `${T}Changed`;\ntype T0 = EventName<'foo'>;  // 'fooChanged'\ntype T1 = EventName<'foo' | 'bar' | 'baz'>;  // 'fooChanged' | 'barChanged' | 'bazChanged'\n\n\ntype Concat<S1 extends string, S2 extends string> = `${S1}${S2}`;\ntype T2 = Concat<'Hello', 'World'>;  // 'HelloWorld'\n\n字符串模板中的联合类型会被展开后排列组合：\ntype T3 = `${'top' | 'bottom'}-${'left' | 'right'}`;  \n// 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n```\n\n### 1.9.2  新增关键字\n\n为了字符串模板类型这个功能， TS 中新增了四个关键字，用于对模板字符串变量进行处理\n\n```markdown\n-  uppercase — 大写字母\n- lowercase — 小写字母\n- capitalize — 首字母大写 \n- uncapitalize — 首字母小写 \ntype Cases<T extends string> = `${uppercase T} ${lowercase T} ${capitalize T} ${uncapitalize T}`;\ntype T11 = Cases<'bar'>;  // 'BAR bar Bar bar'\n```\n\n### 1.9.3  实现类似于正则匹配提取的功能\n\n配合infer\n\n```typescript\ntype MatchPair<S extends string> = S extends `[${infer A},${infer B}]` ? [A, B] : unknown;\ntype T20 = MatchPair<'[1,2]'>;  // ['1', '2']\ntype T21 = MatchPair<'[foo,bar]'>;  // ['foo', 'bar']\n```\n\n通过 , 分割左右两边，再在左右两边分别用一个 infer 泛型接受推断值 [${infer A},${infer B}]，就可以轻松的重新组合 , 两边的字符串。\n\n### 1.9.4 实现 Join 方法\n\n... 拓展运算符和 infer\n\n```typescript\ntype Join<T extends (string | number | boolean | bigint)[], D extends string> =\n    T extends [] ? '' :\n    T extends [unknown] ? `${T[0]}` :\n    T extends [unknown, ...infer U] ? `${T[0]}${D}${Join<U, D>}` :\n    string;\ntype T30 = Join<[1, 2, 3, 4], '.'>;  // '1.2.3.4'\ntype T31 = Join<['foo', 'bar', 'baz'], '-'>;  // 'foo-bar-baz'\n```\n\n### 1.9.5 实战运用\n\n- 实现 lodash get 函数\n\n```typescript\ntype PropType<T, Path extends string> = string extends Path ? unknown :\n    Path extends keyof T ? T[Path] :\n    Path extends `${infer K}.${infer R}` ? K extends keyof T ? PropType<T[K], R> : unknown :\n    unknown;\ndeclare function get<T, P extends string>(obj: T, path: P): PropType<T, P>;\n```\n\n```typescript\nconst obj = { a: { b: {c: 42, d: 'hello' }}};\n\nconst value = get(obj, \"a.b.c\")\n```\n\n# 2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~\n\n## 2.1 断言\n\n### 2.1.1  非空断言\n\n- 忽略 undefined 和 null 类型\n问题引入：如何在类型定义时忽略 undefined 和 null 类型？\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) {\n  const onlyString: string = maybeString;   // Error\n}\n```\n\n答：使用非空断言解决：\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) {\n  const onlyString: string = maybeString!; // true\n}\n```\n\n从以上示例可以看出，非空断言是⼀个后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ null 和⾮ undefined 类型。具体⽽⾔，x! 将从 x 值域中排除 null 和 undefined 。\n具体示例如下：\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) { \nconst onlyString: string = maybeString; // Error \nconst ignoreUndefinedAndNull: string = maybeString!; // Ok \n}\n```\n\n- 确定赋值断⾔\n问题引入：如何解决下面这个问题？ 与非空断言的区别\n代码遮住\n\n答：使用确定赋值断⾔解决：\n\n```typescript\nlet x！: number; \ninitialize(); \n\nconsole.log(2 * x); // true\nfunction initialize() { \n    x = 10; \n}\n```\n\n通过 let x!: number; 确定赋值断⾔，TypeScript 编译器就会知道该属性会被明确地赋值。\n\n### 2.1.2  类型断言\n\n类型断言就是告诉ts我知道这个变量的类型是什么，它没有运行时的影响，只是在编译阶段起作用\n\n- 类型断言有两种形式。 其一是“尖括号”<>语法：\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- 另一个为as语法：\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。\n\n## 2.2   ?.   可选链运算符\n\n可选链的核⼼ ?. 运算符,遇到 null 或 undefined 就可以⽴即停⽌某些表达式的运⾏。\n🌰  可选的属性访问的例⼦：\n\n```typescript\nconst val = a?.b;\n```\n\n🌰  可选函数调用的例子：\n\n```typescript\nlet result = obj.customMethod?.();\n```\n\n## 2.3  ??  空值合并运算符\n\n问题引入：对于非空判断是否有更优的写法，如：\n\n```typescript\n let num;\n let num1 = 1;\n result = ( num !== null && num !== undefined ) ? num : num1 ;\n ```\n\n答：使用空值合并运算符 ??  \n\n```typescript\n let num;\n let num1 = 1;\n result = num ?? num1 ; // result === 1\n ```\n\n通过以上案例，空值合并运算符就是当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。\n\n```typescript\nconst foo = null ?? 'default string'; \nconsole.log(foo); // 输出：\"default string\" \nconst baz = 0 ?? 42; \nconsole.log(baz); // 输出：0\n```\n\n      与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤ \n|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（''、NaN 或 0）时。\n\n- 与可选链操作符 ?. 搭配使用\n\n```typescript\ninterface Customer { \nname: string; \ncity?: string; \n} \nlet customer: Customer = { \nname: \"Semlinker\" \n}; \nlet customerCity = customer?.city ?? \"Unknown city\"; \nconsole.log(customerCity); // 输出：Unknown city\n```\n\n- 不能与 && 或 || 操作符共⽤\n\n```typescript\nnull || undefined ?? \"foo\"; // raises a SyntaxError \ntrue && undefined ?? \"foo\"; // raises a SyntaxError\n```\n\n 但当使⽤括号来显式表明优先级时是可⾏的，⽐如：\n (null || undefined ) ?? \"foo\"; // 返回 \"foo\"\n\n## 2.4   ?:  可选属性\n\n```typescript\ninterface Person { \n   name: string; \n   age?: number; \n} \n\nlet lolo: Person = { \n   name: \"lolo\" \n}\n```\n\n注意：只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后。\n\n## 2.5  _  数字分隔符\n\n⼀个数字字⾯量，你现在可以通过把⼀个下划线作为它们之间的分隔符来分组数字，分隔符不会改变数值字⾯量的值，但逻辑分组使⼈们更容易⼀眼就能读懂数字\n\n```typescript\nconst inhabitantsOfMunich = 1_464_301; \nconst distanceEarthSunInKm = 149_600_000; \nconst fileSystemPermission = 0b111_111_000; \nconst bytes = 0b1111_10101011_11110000_00001101;\n```\n","source":"_posts/你不知道的TypeScript.md","raw":"---\ntitle: 你不知道的TypeScript\ndate: 2022-03-06 15:14:33\ntags: typescript 基础知识\ndescription: 总结ts的类型层级、枚举、断言等相关知识，更加深入的了解typescript\n---\n\n# 基础概括\n\n## 1.1 枚举\n\n### 1.1.1 背景介绍\n\n维护别人的代码尤其是一些质量较差的代码时，我们常常会碰到以下这样的代码，这样的状态位在之后的开发中很容易混乱。\n\n```typescript\nconst handle = (status: number) => {\n    if (status === 2) {\n        // do something\n    }\n}\n\njson ={\n 'name':'zhangsan'\n 'email':'1234567@qq.com'\n}\n```\n\n所以说这个时候就需要有一个对象可以来将这些状态为做一个集中管理了。\n\n### 1.1.2 基础用法\n\nts中的枚举其他的高级语言的枚举不同的是，ts中的枚举成员的值可以是字符串/数字。\n\n```typescript\nenum NoYes {\n    no = 'no',\n    yes = 'yes',\n}\nenum NoYes {\n    no = 0,\n    yes = 1,\n}\n```\n\n此外，在ts的枚举中也可以使用数字的递增来定义枚举成员。\n\n```typescript\nenum NoYes {\n    no, // 0\n    yes, // 1\n}\n```\n\n但是，在定义数字型枚举作为类型时，便会出现一个松散型的类型检查，它会直接将这个枚举类型当作一个number类型。\n\n```typescript\nenum NoYes {\n    no,\n    yes,\n}\nconst foo = (sig: NoYes) => {\n    // do something...\n}\nfoo(11) // ok! 这个时候是不会报错的\n```\n\n因为这个特性，很容易的引起别人对公共模块乱传参对情况，比如说例子中我们无法对函数foo的入参做一个严格的检查。\n但是当枚举值是字符串时就不再有这个问题了。\n\n```typescript\nenum NoYes {\n    no = 'no',\n    yes = 'yes',\n}\nconst foo = (sig: NoYes) => {\n    // do something。。。\n}\nfoo('no') // error\nfoo(NoYes.no) // ok!\n\n```\n\n所以说，在很多的情况下都是建议采用字符串作为枚举值的，可以起到一个更好的约束作用。\n但是在涉及到与后端的交互的时候，也是没办法的，是数字就还是得用数字，如果说擅自将数字改成字符串的还是会引起一些不必要的麻烦的。遗憾的是，之后的ts版本，将不会再去更新会影响代码运行的内容，所以说对于数字枚举松散型的问题，在后期也是不会再去解决了。\n于是，我们也可以采用这种方法：\n\n```typescript\nenum NoYes {\n    no, // 0\n    yes, // 1\n}\nconst foo = (sig: keyof typeof NoYes) => {\n    // do something。。。\n}\nfoo(11) // error\nfoo('no') // ok!\n```\n\n相比于枚举类型的数字，字符串还是比较好理解的，同时对入参的格式限制也还是有比较准确的定义，可以很好的检查出存不存在乱传参的行为。\n\n1.1.3 运行时的枚举\n上文说到枚举是少数的会参与代码运行的ts的内容之一，因此枚举是会被编译成js代码的。\n以简单的NoYes枚举为例：\n\n```typescript\nenum NoYes {\n  No,\n  Yes,\n}\n```\n\nts将这个枚举编译为：\n\n```typescript\nvar NoYes;\n(function (NoYes) {\n  NoYes[NoYes[\"No\"] = 0] = \"No\";\n  NoYes[NoYes[\"Yes\"] = 1] = \"Yes\";\n})(NoYes || (NoYes = {}));\n```\n\n通过编译后的代码我们可以看出，枚举具有反向映射的功能，可以通过值反向获取到枚举成员。\n\n```typescript\nenum NoYes {\n  No,\n  Yes,\n}\nNoYes.yes // 1\nNoYes[NoYes.yes] // yes\n```\n\n为了减小代码运行时的负担，也有了一个常量枚举，让枚举只是参与开发过程，而不在参与js的运行过程。\n\n```typescript\nconst enum NoYes {\n  No,\n  Yes,\n}\n```\n\n以上的NoYes枚举在编译之后是会与类型一样被删除的，而在使用也会有区别。const枚举会失去反向映射的功能\n\n```typescript\nconst enum NoYes {\n  No,\n  Yes,\n}\nconst val1 = NoYes.yes // ok! val1 = 1\nconst val2 = NoYes[NoYes.yes] // error!  val2 = undefined\n```\n\n编译完之后的代码也会去掉enum的定义，引用的也直接给一个定值\n\n```typescript\nconst val1 = 1;\nconst val2 = undefined;\n```\n\n这样对于缩小打包后的代码体积起到了一定的作用，在开发的过程中可以根据实际情况去使用const枚举，同时这样对打包后的代码也可以起到一个更好的加密效果。\n\n### 1.1.4 对象枚举\n\n在没有ts的时候写js代码，我们对枚举的定义都会使用一个对象写出一个枚举\n\n```typescript\n// ./enmus.js\nexport const StatusEnum = {\n    off: 0,\n    on: 1\n}\n\nimport { StatusEnum } from './enums'\n\n// ...\nconst handle = (status) => {\n    if (status === StatusEnum.off){\n        // do something....\n    }\n}\n// ...\n```\n\n在ts项目中，这样的方式去定义枚举也不是不可以的，但是这时候我们可以去设置一个as const只读属性。\n\n```typescript\n// ./enmus.js\nexport const StatusEnum = {\n    off: 0,\n    on: 1\n} as const\n```\n\n对象枚举的优点：\n\n```markdown\n将旧的js代码改造成ts更加的方便\n可以对键值加计算逻辑\n枚举值可以是Symbol类型\n\n对象枚举的缺点\n无法反向映射\n对于枚举值的类型描述困难，透传的时候不好去描述类型（可以自己写一个ValueOf工具类型，但是有理解成本，如下代码）\n```\n\n```typescript\nexport const NoYes = {\n    yes: 1,\n    no: 0\n} as const\n```\n\n```typescript\n// 获取值\ndeclare type ValueOf<T> = T extends {[K in keyof T]: infer V } ? V : never;\nconst handle1 = (k: keyof typeof NoYes) => { // 通过keyof typeof约束类型，但是不好去透传\n    // do something...\n}\nconst handle2 = （v: ValueOf<typeof NoYes>) => { // 可以透传枚举值，但是ValueOf有理解成本\n    // do something...\n}\n```\n\n## 1.2 类型守卫\n\n### 1.2.1 类型的层级\n\n在前面提到了顶级类型的概念，在ts中，类型是有自己的层级的，当一个类型可以被一个类型约束时，那么这个这两个类型便构成了上下级的关系（这节我们就排除any，它是一个特殊的例子）。类型也只能在同级和下级到上级传递，他们也构成了一个单向的传递关系。这也就是任何类型都可以给unknown，never可以给任何类型的原因。\n\n```typescript\nconst foo = (arg: T1 | T2 | undefined) => {\n    // do something;\n}\nconst obj1: T1 = {\n//...\n};\nconst obj2: T2 = {\n//..\n}; \nlet obj3: T3\nfoo(undefined) // ok!!\nfoo(obj1); // ok!!\nfoo(obj2); // ok!!\nfoo(obj3); // ok!!\n```\n\n不过值得注意的是，在非基础类型内部，上下级的关系就是不一样的了。\n\n```typescript\ntype T1 = {\n  a: string,\n  b: number\n  c: boolean\n}\ntype T2 = {\n  a: string,\n  b: number\n}\n\nconst foo1 = (arg: T2) => {\n    // do something\n}\nconst obj1: T1 = {\n  a: 'aa',\n  b: 1,\n  c: true\n}\nfoo1(obj1)； // ok！！\n```\n\n但是，在开发过程中难免会遇到类型不小心被放大的情况，然后被ts提示有不严谨的地方。(这种时候可能又会有人骂骂咧咧的说ts不好了)\n在这个是时候其实需要对类型做一个守卫，从而再将类型进行收窄。\n\n### 1.2.2 类型收窄\n\n说起类型收窄，我们首先可以想到的在js中所拥有的\n\n```markdown\n类型判断：typeof；\n实例判断：instanceof；\n属性判断：in；\n字面量相等判断：==，===，!=，!==；\n```\n\n它们在代码书写的时候都将通过if else和switch起到一定的类型守卫的作用，ts也可以对所参与的变量起到一个类型收窄的作用。\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\ntype T2 = {\n  a: number;\n  b: number;\n  d: 'type2';\n}\nconst foo1 = (arg?: T1 | T2 | string) => {\n  if (!arg) return;\n  // arg is T1 | T2 | string\n  if (typeof arg === 'string') {\n      // arg is string\n  } else {\n      // arg is T1 | T2\n      if ('c' in arg) {\n        // arg is T1\n      }\n      if (arg.d === 'type1') {\n        // arg is T1\n      }\n      if (arg.d === 'type2') {\n          // arg is T2\n      }\n  }\n}\n```\n\n在后面的章节中会讲到，never是所有类型的子类型，所以说never是所有类型的下级类型。\n所以说我们可以这么理解\n\n```typescript\ntype T1 = {\n    a: string | never;\n    b: number | never;\n    c: boolean | never;\n} | never\ntype T2 = {\n    a: string | never;\n    b: number | never;\n    d: string | never;\n} | never\n```\n\n每一个已知类型都是会被ts联合一个never的子类型的，当然这个联合不是我们自己写上去的。\n所以说我们在使用if，switch做类型收窄的时候就会发现，当我们吧所有的已知类型都考虑完之后，编辑器就会出现一个never未知类型\n\n```typescript\ntype T1 = {\n    a: 'a' | 'b' | 'c';\n    // any other keys;\n}\nconst foo = (arg: T1) => {\n    switch(arg.a) {\n        case 'a': \n            // do something...\n            break;\n        case 'b':\n            // do something...\n            break;\n        case 'c':\n            // do something...\n            break;\n        default \n            // arg.a is never\n    }\n}\n```\n\n通过我们上面对never以及上下子类型的理解，知道了T1类型是会被ts给完整的写成\n\n```typescript\ntype T1 = {\n    a: 'a' | 'b' | 'c' ｜ never;\n    // any other keys;\n} | never;\n```\n\n在开发中我们可以用if else和switch将类型收窄，也可能会想到通过类型断言将类型收窄。\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\ntype T2 = {\n  a: number;\n  b: number;\n  d: 'type2';\n}\nconst  foo1 = ( arg: T1 | T2 ) => {\n    // do something....\n}\n\nlet t1: T1 | T2 | string | undefined\n// do something...\nfoo1(t1) // error!！ T1 | T2 | string | undefined类型不能给T1 | T2\nfoo1(t1 as T1) // ok\nfoo1(t1 as T2) // ok\nfoo1(t1 as T1 | T2) // ok\n```\n\n这种情况下很大的可能是一些个人原因没定义好类型，在更多的情况下我们遇到的是一个可能为空的情况，于是我们也可以使用非空断言\n\n```typescript\ntype T1 = {\n  a: string;\n  b: number;\n  c: boolean;\n  d: 'type1';\n}\n\nlet t: T1 // t is T1 | undefined\n// do something...\nconst foo = (arg: T1) => {\n    // do something...\n}\nfoo(t) // error! t的值很有可能为undefined。\nfoo(t!) // ok! 通过非空断言（!）断言t不是undefined和null\n```\n\n不管怎样，断言收窄还是不建议乱去使用的，更加推荐的是使用is去做一个类型收窄\n\n```typescript\nconst projectType = <T>(\n    data: unknown,\n    cb: (arg: unknown) => boolean\n): data is T => {\n  return cb(data)\n}\n\ntype T1 = {\n    a: string;\n    b: number;\n}\ntype T2 = {\n    c: boolean;\n    d: number;\n}\nconst foo = (arg?: T1 | T2) => {\n    if (!arg) return;\n    // arg is T1 | T2\n    if (projectType<T1>(arg, (a) => !!(a as T1)?.a)) {\n        // arg is T1\n    } else {\n        // arg is T2\n    }\n}\n```\n\n使用is去做类型守卫，看似麻烦了很多。但是从逻辑层面去对数据进行了一个类型收窄，相比于断言，这样可以很大的降低运行时的风险。（当然那个判定逻辑不能随便去写）\n\n### 小结\n\n```markdown\n类型守卫的核心是将类型收窄，可以将类型收窄成它的子类型\n可以灵活的使用js中的相关内容对一个类型做相应的收窄\n断言只能在上下级类型断言！不可以在没有上下级关系的类型之间断言，相关的区别会在本文中的断言中做详细介绍。\n断言属于欺骗编译器的行为，并不会在运行过程中起作用，在开发中不可以盲目断言！更推荐于使用if else加is去做一个逻辑层的类型守卫。\n```\n\n## 1.3 any、unknown、never\n\n### 1.3.1 any、unknown、never对比\n\nts作为一个静态语言，与强类型还是有所区别的。强类型是将代码编译成另一种语言的代码的，但是静态语言还是逃脱不了是一个弱类型的本质，有很多时候还是可以逃避的。所以说很多时候我们会看到的是能有any，unknown，never这样的隐式类型。\n它们的区别如下：\nany属于顶级、底级类型，所有的类型都可以给any，any类型可以给其他任何类型；\nunknown属于顶级类型，所有的类型都可以给unknown，但是在unknown调用方法时必须要对unknown做存在的判断；\nnever属于底级类型，它可以给所有已知类型，但是已知类型不可以给never类型；\n\n### 1.3.2 any是top type和bottom type\n\n写过ts代码的人，对any可能是非常熟悉的一个东西了，毕竟any可以解决很多的问题。\n在ts的提案中，any属于顶级类型，任何类型都可以赋给它。\n\n```typescript\nconst handle (item: any) => {\n    // do something...\n}\n\nconst str: string = \"hello world!\"\nconst num: number = 100\nconst isYes = true\nhandle(str) // ok!!\nhandle(num) // ok!!\nhandle(isYes) // ok!!\n```\n\n同时any也是底级类型，它可以赋给任何类型\n\n```typescript\nconst a1: any\nconst str: string = a1; // ok!\nconst num: number = a1; // ok!\n```\n\n所以说，any的优点还是挺明显的，但是any肯定不是可以让你类型自由的工具。对于代码中还是要尽量的去写已知类型。\n\n### 1.3.3 unknown是顶级的类型\n\n在其他的很多文章中都说unknown和any很像或者类似，但是这个说法也不是那么准确。\nunknown在ts的提案中定义为了一个顶级的类型。任何类型都可以赋给unknown，在使用unknown的时候需要将类型收窄。\n\n```typescript\nconst foo = (arg: unknown) => {\n    arg.push() // error!!\n    if (typeof arg === 'array') {\n        arg.push() // ok\n    }\n}\n```\n\ntry catch 语句中的catch后面的error参数会是unknown，然后有的时候我们会碰到比较难处理的情况，我们这个时候也可以使用断言进行类型收窄。\n\n```typescript\ntry {\n  // do something...\n} catch (err) {\n  // err is unknown\n  if((err as Error )?.message === '...') {\n    const error = err as Error\n    // error is Error\n  }\n}\n```\n\n上面的收窄方式可能还是太机械性了，重复的代码写的太多，我们也可以使用is关键字对unknown进行类型收窄\n\n```typescript\n/**\n * 对数据进行类型守卫的函数\n * @param data 守卫的数据\n * @param cb 判断守卫的函数，把能够确定的逻辑写进来，返回true就是确定这个类型\n * @returns 第二个参数返回true为这个类型，否则不是\n */\nconst projectType = <T>(\n    data: unknown,\n    cb: (arg: unknown) => boolean\n): data is T => {\n  return cb(data)\n}\n\ntry {\n  // do something...\n} catch (err) {\n  // err is unknown\n  if(projectType<Error>(err, (e) => !!(e as Error)?.message)) {\n    // err is Error\n  }\n}\n```\n\n### 1.3.4 never是所有类型的子类型\n\n由上面的对比可知，never可以是所有类型的子类型，在有已知类型的时候，never就会直接合并入已知类型中，不再有never类型。\n\n```typescript\nconst T1: number | never // number\nconst T2: unknown | never // unknown\nconst T3: string | number | never // string | number\nconst T4: never //never\n```\n\n所以说never类型可以表示为一个无法推断出来的类型，这个在很多的工具类型特别是使用infer的类型中可以看到。表示的都是无法推断出想要得到的类型。\n\n```typescript\n// 是否为空类型\ntype NonNullable<T> = T extends null | undefined ? never : T;\n// 获取函数参数类型的元数组\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n\n// 取U中的非T部分\ntype Exclude<T, U> = T extends U ? never : T;\n// 取U中的T部分\ntype Extract<T, U> = T extends U ? T : never;\n```\n\n此外，never还可以表示的是未知类型，意思为它不属于任何一种类型，这种情况下在switch和if else语句中尤为明显，对这个的处理的也能体现出，逻辑代码是否能够考虑极端情况，对代码的稳定性的提高显得尤为重要。\n\n```typescript\nenum NoYes { no, yes }\nconst handleErr = (e: Error) => {\n    // do something;\n}\nconst foo = (type: NoYes) => {\n    switch(type) {\n        case NoYes.yes: \n            // do something....\n        break;\n        case NoYes.no:\n            // do something...\n        break;\n        default: \n        /* 这种case的时候就是一个never类型，\n         * 这种never类型可以给其他的任何类型\n        */\n            handleErr(type); // ok!\n    }\n}\n```\n\n### 小结\n\n```markdown\n介绍到这里，或许大家可以对any，unknown与never有一个了解，在使用的时候也有相应的几点建议：\n减少未知类型的出现，少写甚至不写any；\n对类型的声明要做到准确，避免隐式类型；\n对never类型能够做合理拦截；\n对于unknown类型能够做出合理的类型收窄；\n```\n\n## 1.4 联合undefined 与可选在实际使用过程中的区别\n\n### 1.4.1 对象中键值设置为undefined和没有它的区别\n\n由于js的灵活性，也是能够允许对象中的键值为null和undefined。但是设置为undefined的时候最重要的一点是可以被遍历到。\n\n```typescript\nconst obj = {a: 1, b: 2};\nobj.b = undefined;\nfor (const k in obj) {\n    console.log(k);\n}\n// a, b\n\nconst obj = {a: 1, b: 2};\n// @ts-ignore\ndelete obj.b\nfor (const k in obj) {\n    console.log(k);\n}\n// a\n```\n\n为了表示出对象中的缺别，我们就有了键值联合undefined和可选的区别了\n\n### 1.4.2 ts类型的undefined联合和可选\n\n许多人在写ts的时候很早的时候就会注意到那个可选值，然后有的时候也可会观察到有一些的组件库的类型是{k: string | undefined}类型。甚至还会疑惑为什么不是写 ?: (毕竟 ?: 字符少，写起来方便^_^！！)。\n这个地方就牵扯到ts类型的一个小细节了。\n\n```typescript\ntype T1 = {\n    a: number;\n    b: string;\n    c: boolean ｜ undefined;\n    d?: number;\n}\nconst obj1: T1 = { a: 1, b: '1', c: true } // ok\nconst obj2: T1 = { a: 1, b: '1', c: true, d: 2 } // ok\nconst obj3: T1 = { a: 1, b: '1', d: 2 } // error，缺少键值c\nconst obj4: T1 = { a: 1, b: '1', c: undefined, d: 2 } // ok\nconst obj5: T1 = { a: 1, b: '1', c: true, d: undefined } // ok\nconst obj6: T1 = { a: 1, b: '1', c: true, d: '2' } // error, d的类型不对\n```\n\n当一个类型的键使用可选声明时，这个键代表的就是可有可无了（有肯定是约定好的类型），但是设置为undefined联合时，这个键就必须得有了。\n而且在我们将键设置为可选时，我们可以对该键进行delete，依然以上面的obj对象为例\n\n```typescript\ndelete obj3.d // ok！！\ndelete obj5.c // error!!\n```\n\n### 小结\n\n```markdown\n开发过程中对非基础类型中的undefined属性定义要合理\n为了减少可选类型对维护的时候带来的误解，可以使用| undefined来代替可选\n```\n\n## 1.5 object、Object与{}\n\n### 1.5.1 基本类型\n\n在ts中，基本类型包括string、number、boolean、symbol、[]、enum、undefined、null、void、unknown、never、any等。详细可见：<https://juejin.cn/post/7006304933813157919>\n它们构成了ts的基本类型，由ts内部自己定义。\n\n### 1.5.2 非基本类型\n\n除了上述的基本类型外，其他的类型都为非基本类型。ts2.7版本中被提出object类型，表示ts中的非基本类型。在此之前，lib.d.ts中收录了Object类型来表示非基本类型。\n所以说，类似于以下类型，都称为非基本类型\n\n```typescript\ninterface T1 {\n  a: string;\n  b: number;\n  c: boolean;\n  // ...\n}\ninterface T2 {\n  a: number;\n  b: number;\n  d: 'type2';\n  // ...\n}\n```\n\n同时在ts的lib.d.ts中，我们也是可以看到有Object的声明的\n\n```typescript\n/**\n * Provides functionality common to all JavaScript objects.\n */\ndeclare var Object: ObjectConstructor;\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    // ...\n}\n```\n\nobject相当于就是将Object定义成一个基本类型。\nobject与Object的各有以下特点：\n\n```markdown\nobject是ts内部定义的基本类型，表示的是非基本类型，不可被重写；\nObject类型为lib.d.ts中声明的非基本类型，可以被改写\n```\n\n### 1.5.3 Object是所有的非基本类型的父类型\n\n所有的非基本类型中，都会继承Object类型。这个也是ts自身赋予的，不需要我们去写。我们在使用一个非基本类型的时候，是可以使用到hasOwnProperty、valueOf、length等原型属性的。\n\n```typescript\ninterface T1 {\n    a: string;\n    b: number;\n}\n\nconst p: T1 = {\n    a: 'a',\n    b: 1\n}\np.hasOwnProperty('a'); //ok! Object上有这个方法\n```\n\n### 小结\n\n```markdown\nobject是基本类型，它表示非基本类型Object\n不建议将变量类型直接声明为object或Object，除非真的只用object的原型属性\nObjectConstructor有一些方法类型定义不够准确，可以尝试去改写它\n```\n\n## 1.6 interface 和 type  自定义类型\n\n大家使用 typescript 总会使用到 interface 和 type,但是很少能够真正区分它俩，接下来介绍下他们之间的区别\n1、相同点\n\n- 都可以描述一个对象或者函数\n\n```typescript\n// interface定义对象\ninterface User {\n  name: string\n  age: number\n}\n\n// interface定义函数\ninterface SetUser {\n  (name: string, age: number): void;\n}\n\n// type定义对象\ntype User = {\n  name: string\n  age: number\n};\n\n// type定义函数\ntype SetUser = (name: string, age: number)=> void;\n```\n\n- 都允许拓展（extends）\ninterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\ninterface使用extends、implements组合类型 , type则可以通过&, |符号组合、合并类型。\n1 interface extends interface\n\n```typescript\ninterface Name { \n  name: string; \n}\n\ninterface User extends Name { \n  age: number; \n}\n```\n\n2. type extends type\n\n```typescript\ntype Name = { \n  name: string; \n}\n\ntype User = Name & { age: number  };\n\n```\n\n3. interface extends type\n\n```typescript\ntype Name = { \n  name: string; \n}\ninterface User extends Name { \n  age: number; \n}\n```\n\n4. type extends interface\n\n```typescript\ninterface Name { \n  name: string; \n}\ntype User = Name & {\n  age: number;\n}\n```\n\n2、不同点\n\n- type 可以声明基本类型别名，联合类型，元组等类型\n\n```typescript\n// 基本类型别名\ntype Name = string\n\n// 联合类型\ninterface Dog {\n    wong();\n}\ninterface Cat {\n    miao();\n}\n\ntype Pet = Dog | Cat\n\n// 具体定义数组每个位置的类型\ntype PetList = [Dog, Pet]\n\n- type 语句中还可以使用 typeof 获取实例的 类型进行赋值\n// 当你想获取一个变量的类型时，使用 typeof\nconst foo = {\n    a: 'a',\n    b: 2,\n    c: true\n}\ntype Foo = typeof foo //{ a: string, b: 2, c: boolean }\n```\n\n- interface 能够声明合并，也是interface 一个比较强大的地方，可以重复定义添加属性，type不行\n\n```typescript\ninterface User { \n    name: string \n    age: number \n} \ninterface User { sex: string } \n/* User 接口为 { name: string age: number sex: string } */\n```\n\n## 1.7  & 交叉类型\n\n在 TypeScript 中交叉类型是将多个类型合并为⼀个类型。通过 & 运算符可以将现有的多种类型叠加到 ⼀起成为⼀种类型，它包含了所需的所有类型的特性。\n\n```typescript\ntype X = { \n   x: number; \n}; \ntype Point = X & { y: number; }; // 定义point的类型：  合并X和y的类型\n\nlet point: Point = { \n    x: 1, \n    y: 1 \n}\n```\n\n- 同名基础类型属性的合并\n那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型 ⼜不⼀致，⽐如：\n\n```typescript\ninterface X { \n    c: string; \n    d: string; \n}\ninterface Y { \n    c: number; \n    e: string \n} \ntype XY = X & Y; \ntype YX = Y & X; \nlet p: XY; \nlet q: YX;\n```\n\n在上⾯的代码中，接⼝ X 和接⼝ Y 都含有⼀个相同的成员 c，但它们的类型不⼀致。对于这种情况，此 时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 string 或 number 类型呢？⽐如下⾯的例⼦：\n\n```typescript\np = { c: 6, d: \"d\", e: \"e\" }; // 接上面的示例\nq = { c: \"c\", d: \"d\", e: \"e\" };\n```\n\n为什么接⼝ X 和接⼝ Y 混⼊后，成员 c 的类型会变成 never 呢？这是因为混⼊后成员 c 的类型为\nstring & number ，即成员 c 的类型既可以是 string 类型⼜可以是 number 类型。很明显这种类型\n是不存在的，所以混⼊后成员 c 的类型为 never，因避免出现类似情况\n\n- 同名⾮基础类型属性的合并\n\n```typescript\ninterface D { d: boolean; }\ninterface E { e: string; }\ninterface F { f: number; }\ninterface A { x: D; }\ninterface B { x: E; }\ninterface C { x: F; }\ntype ABC = A & B & C;\nlet abc: ABC = {\n    x: {\n      d: true, e: 'semlinker', f: 666\n    }\n};\nconsole.log('abc:', abc);\n```\n\n由上图可知，在混⼊多个类型时，若存在相同的成员，且成员类型为⾮基本数据类型，那么是可以成功合并。\n\n## 1.8 Tuple 类型\n\n我们知道数组中元素的数据类型一般都是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。元组中允许存储不同类型的元素，元组可以作为参数传递给函数。\n\n- 声明一个元组mytuple，并初始化：\n\n```typescript\nlet mytuple: [number, string]\nvar mytuple = [10,\"Runoob\"];\n```\n\n- 访问元组\n\n```typescript\nconsole.log(mytuple[0]) // 10\nconsole.log(mytuple[1]) // Runoob\n```\n\n- 可选元组\n元组类型允许在元素类型后缀一个 ? 来说明元素是可选的：\n\n```typescript\nlet mytuple: [number, string?，boolean?]\nlet mytuple = [10,\"Runoob\",ture];\nlet mytuple1 = [10,\"Runoob\"];\nlet mytuple2 = [10,];\n```\n\n- 元组越界\n可以越界添加元素（不建议），但不可越界访问，有可选元素更不建议使用元组越界，因为可选元素一般都在最后\n\n```typescript\nlet mytuple: [number, string] = [10,\"Runoob\"];\nmytuple.push('hello world')\n\nconsole.log(mytuple) // [10, 'Runoob', 'hello world' ] \nconsole.log(list[2]) // Tuple type '[string, number]' of length '2' has no element at index '2'\n```\n\n- 命名元组类型\n命名元组类型适需要 TypeScript 4.0及以上版本才能使用，它极大的改善了我们的开发体验及效率，先来看一个例子:\n\n```typescript\ntype Address = [string, number]\nfunction setAddress(...args: Address) {\n  console.log(args)\n}\n```\n\n当我们这样定义函数入参后，在使用函数时，编辑器的智能提示只会提示我们参数类型，丢失了对参数含义的描述。\n\n为了改善这一点，我们可以通过命名元组类型，我们可以这样定义参数：\n\n```typescript\ntype Address = [streetName: string, streetNumber: number]\n\nfunction setAddress(...args: Address) {\n  console.log(args)\n}\n```\n\n这样，在调用函数时，我们的参数就获得了相应的语义，这使得代码更加容易维护。\n这两种⽅式看起来没有多⼤的区别，但对于第⼀种⽅式，我们没法设置第⼀个参数和第⼆个参数的名称。虽然这样对类型检查没有影响，但在元组位置上缺少标签，会使得它们难于使⽤。为了提⾼开发者使⽤元组的体验，TypeScript 4.0 ⽀持为元组类型设置标签\n\n- 典型应用 useState\n\n```typescript\nimport { useState } from 'react';\nconst [loading, setLoading] = useState<boolean>(false);\n```\n\n## 1.9 字符串模板类型\n\n### 1.9.1  基础语法\n\n它的语法和 es 里的字符串模板很相似，所以上手成本也很低，先看几个🌰：\n\n```typescript\ntype EventName<T extends string> = `${T}Changed`;\ntype T0 = EventName<'foo'>;  // 'fooChanged'\ntype T1 = EventName<'foo' | 'bar' | 'baz'>;  // 'fooChanged' | 'barChanged' | 'bazChanged'\n\n\ntype Concat<S1 extends string, S2 extends string> = `${S1}${S2}`;\ntype T2 = Concat<'Hello', 'World'>;  // 'HelloWorld'\n\n字符串模板中的联合类型会被展开后排列组合：\ntype T3 = `${'top' | 'bottom'}-${'left' | 'right'}`;  \n// 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n```\n\n### 1.9.2  新增关键字\n\n为了字符串模板类型这个功能， TS 中新增了四个关键字，用于对模板字符串变量进行处理\n\n```markdown\n-  uppercase — 大写字母\n- lowercase — 小写字母\n- capitalize — 首字母大写 \n- uncapitalize — 首字母小写 \ntype Cases<T extends string> = `${uppercase T} ${lowercase T} ${capitalize T} ${uncapitalize T}`;\ntype T11 = Cases<'bar'>;  // 'BAR bar Bar bar'\n```\n\n### 1.9.3  实现类似于正则匹配提取的功能\n\n配合infer\n\n```typescript\ntype MatchPair<S extends string> = S extends `[${infer A},${infer B}]` ? [A, B] : unknown;\ntype T20 = MatchPair<'[1,2]'>;  // ['1', '2']\ntype T21 = MatchPair<'[foo,bar]'>;  // ['foo', 'bar']\n```\n\n通过 , 分割左右两边，再在左右两边分别用一个 infer 泛型接受推断值 [${infer A},${infer B}]，就可以轻松的重新组合 , 两边的字符串。\n\n### 1.9.4 实现 Join 方法\n\n... 拓展运算符和 infer\n\n```typescript\ntype Join<T extends (string | number | boolean | bigint)[], D extends string> =\n    T extends [] ? '' :\n    T extends [unknown] ? `${T[0]}` :\n    T extends [unknown, ...infer U] ? `${T[0]}${D}${Join<U, D>}` :\n    string;\ntype T30 = Join<[1, 2, 3, 4], '.'>;  // '1.2.3.4'\ntype T31 = Join<['foo', 'bar', 'baz'], '-'>;  // 'foo-bar-baz'\n```\n\n### 1.9.5 实战运用\n\n- 实现 lodash get 函数\n\n```typescript\ntype PropType<T, Path extends string> = string extends Path ? unknown :\n    Path extends keyof T ? T[Path] :\n    Path extends `${infer K}.${infer R}` ? K extends keyof T ? PropType<T[K], R> : unknown :\n    unknown;\ndeclare function get<T, P extends string>(obj: T, path: P): PropType<T, P>;\n```\n\n```typescript\nconst obj = { a: { b: {c: 42, d: 'hello' }}};\n\nconst value = get(obj, \"a.b.c\")\n```\n\n# 2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~\n\n## 2.1 断言\n\n### 2.1.1  非空断言\n\n- 忽略 undefined 和 null 类型\n问题引入：如何在类型定义时忽略 undefined 和 null 类型？\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) {\n  const onlyString: string = maybeString;   // Error\n}\n```\n\n答：使用非空断言解决：\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) {\n  const onlyString: string = maybeString!; // true\n}\n```\n\n从以上示例可以看出，非空断言是⼀个后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ null 和⾮ undefined 类型。具体⽽⾔，x! 将从 x 值域中排除 null 和 undefined 。\n具体示例如下：\n\n```typescript\nfunction myFunc(maybeString: string | undefined | null) { \nconst onlyString: string = maybeString; // Error \nconst ignoreUndefinedAndNull: string = maybeString!; // Ok \n}\n```\n\n- 确定赋值断⾔\n问题引入：如何解决下面这个问题？ 与非空断言的区别\n代码遮住\n\n答：使用确定赋值断⾔解决：\n\n```typescript\nlet x！: number; \ninitialize(); \n\nconsole.log(2 * x); // true\nfunction initialize() { \n    x = 10; \n}\n```\n\n通过 let x!: number; 确定赋值断⾔，TypeScript 编译器就会知道该属性会被明确地赋值。\n\n### 2.1.2  类型断言\n\n类型断言就是告诉ts我知道这个变量的类型是什么，它没有运行时的影响，只是在编译阶段起作用\n\n- 类型断言有两种形式。 其一是“尖括号”<>语法：\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- 另一个为as语法：\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。\n\n## 2.2   ?.   可选链运算符\n\n可选链的核⼼ ?. 运算符,遇到 null 或 undefined 就可以⽴即停⽌某些表达式的运⾏。\n🌰  可选的属性访问的例⼦：\n\n```typescript\nconst val = a?.b;\n```\n\n🌰  可选函数调用的例子：\n\n```typescript\nlet result = obj.customMethod?.();\n```\n\n## 2.3  ??  空值合并运算符\n\n问题引入：对于非空判断是否有更优的写法，如：\n\n```typescript\n let num;\n let num1 = 1;\n result = ( num !== null && num !== undefined ) ? num : num1 ;\n ```\n\n答：使用空值合并运算符 ??  \n\n```typescript\n let num;\n let num1 = 1;\n result = num ?? num1 ; // result === 1\n ```\n\n通过以上案例，空值合并运算符就是当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。\n\n```typescript\nconst foo = null ?? 'default string'; \nconsole.log(foo); // 输出：\"default string\" \nconst baz = 0 ?? 42; \nconsole.log(baz); // 输出：0\n```\n\n      与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤ \n|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（''、NaN 或 0）时。\n\n- 与可选链操作符 ?. 搭配使用\n\n```typescript\ninterface Customer { \nname: string; \ncity?: string; \n} \nlet customer: Customer = { \nname: \"Semlinker\" \n}; \nlet customerCity = customer?.city ?? \"Unknown city\"; \nconsole.log(customerCity); // 输出：Unknown city\n```\n\n- 不能与 && 或 || 操作符共⽤\n\n```typescript\nnull || undefined ?? \"foo\"; // raises a SyntaxError \ntrue && undefined ?? \"foo\"; // raises a SyntaxError\n```\n\n 但当使⽤括号来显式表明优先级时是可⾏的，⽐如：\n (null || undefined ) ?? \"foo\"; // 返回 \"foo\"\n\n## 2.4   ?:  可选属性\n\n```typescript\ninterface Person { \n   name: string; \n   age?: number; \n} \n\nlet lolo: Person = { \n   name: \"lolo\" \n}\n```\n\n注意：只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后。\n\n## 2.5  _  数字分隔符\n\n⼀个数字字⾯量，你现在可以通过把⼀个下划线作为它们之间的分隔符来分组数字，分隔符不会改变数值字⾯量的值，但逻辑分组使⼈们更容易⼀眼就能读懂数字\n\n```typescript\nconst inhabitantsOfMunich = 1_464_301; \nconst distanceEarthSunInKm = 149_600_000; \nconst fileSystemPermission = 0b111_111_000; \nconst bytes = 0b1111_10101011_11110000_00001101;\n```\n","slug":"你不知道的TypeScript","published":1,"updated":"2022-03-06T07:16:25.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eypmza0003kqfyh5rg4kc2","content":"<h1 id=\"基础概括\"><a href=\"#基础概括\" class=\"headerlink\" title=\"基础概括\"></a>基础概括</h1><h2 id=\"1-1-枚举\"><a href=\"#1-1-枚举\" class=\"headerlink\" title=\"1.1 枚举\"></a>1.1 枚举</h2><h3 id=\"1-1-1-背景介绍\"><a href=\"#1-1-1-背景介绍\" class=\"headerlink\" title=\"1.1.1 背景介绍\"></a>1.1.1 背景介绍</h3><p>维护别人的代码尤其是一些质量较差的代码时，我们常常会碰到以下这样的代码，这样的状态位在之后的开发中很容易混乱。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle</span> = (<span class=\"params\">status: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">json =&#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;zhangsan&#x27;</span></span><br><span class=\"line\"> <span class=\"string\">&#x27;email&#x27;</span>:<span class=\"string\">&#x27;1234567@qq.com&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以说这个时候就需要有一个对象可以来将这些状态为做一个集中管理了。</p>\n<h3 id=\"1-1-2-基础用法\"><a href=\"#1-1-2-基础用法\" class=\"headerlink\" title=\"1.1.2 基础用法\"></a>1.1.2 基础用法</h3><p>ts中的枚举其他的高级语言的枚举不同的是，ts中的枚举成员的值可以是字符串&#x2F;数字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"string\">&#x27;no&#x27;</span>,</span><br><span class=\"line\">    yes = <span class=\"string\">&#x27;yes&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"number\">0</span>,</span><br><span class=\"line\">    yes = <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，在ts的枚举中也可以使用数字的递增来定义枚举成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no, <span class=\"comment\">// 0</span></span><br><span class=\"line\">    yes, <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，在定义数字型枚举作为类型时，便会出现一个松散型的类型检查，它会直接将这个枚举类型当作一个number类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no,</span><br><span class=\"line\">    yes,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">11</span>) <span class=\"comment\">// ok! 这个时候是不会报错的</span></span><br></pre></td></tr></table></figure>\n\n<p>因为这个特性，很容易的引起别人对公共模块乱传参对情况，比如说例子中我们无法对函数foo的入参做一个严格的检查。<br>但是当枚举值是字符串时就不再有这个问题了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"string\">&#x27;no&#x27;</span>,</span><br><span class=\"line\">    yes = <span class=\"string\">&#x27;yes&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something。。。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;no&#x27;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"title class_\">NoYes</span>.<span class=\"property\">no</span>) <span class=\"comment\">// ok!</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>所以说，在很多的情况下都是建议采用字符串作为枚举值的，可以起到一个更好的约束作用。<br>但是在涉及到与后端的交互的时候，也是没办法的，是数字就还是得用数字，如果说擅自将数字改成字符串的还是会引起一些不必要的麻烦的。遗憾的是，之后的ts版本，将不会再去更新会影响代码运行的内容，所以说对于数字枚举松散型的问题，在后期也是不会再去解决了。<br>于是，我们也可以采用这种方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no, <span class=\"comment\">// 0</span></span><br><span class=\"line\">    yes, <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: keyof <span class=\"keyword\">typeof</span> NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something。。。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">11</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;no&#x27;</span>) <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n\n<p>相比于枚举类型的数字，字符串还是比较好理解的，同时对入参的格式限制也还是有比较准确的定义，可以很好的检查出存不存在乱传参的行为。</p>\n<p>1.1.3 运行时的枚举<br>上文说到枚举是少数的会参与代码运行的ts的内容之一，因此枚举是会被编译成js代码的。<br>以简单的NoYes枚举为例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ts将这个枚举编译为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">NoYes</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">NoYes</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>[<span class=\"string\">&quot;No&quot;</span>] = <span class=\"number\">0</span>] = <span class=\"string\">&quot;No&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>[<span class=\"string\">&quot;Yes&quot;</span>] = <span class=\"number\">1</span>] = <span class=\"string\">&quot;Yes&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">NoYes</span> || (<span class=\"title class_\">NoYes</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>通过编译后的代码我们可以看出，枚举具有反向映射的功能，可以通过值反向获取到枚举成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>] <span class=\"comment\">// yes</span></span><br></pre></td></tr></table></figure>\n\n<p>为了减小代码运行时的负担，也有了一个常量枚举，让枚举只是参与开发过程，而不在参与js的运行过程。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的NoYes枚举在编译之后是会与类型一样被删除的，而在使用也会有区别。const枚举会失去反向映射的功能</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val1 = <span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span> <span class=\"comment\">// ok! val1 = 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> val2 = <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>] <span class=\"comment\">// error!  val2 = undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>编译完之后的代码也会去掉enum的定义，引用的也直接给一个定值</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val2 = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样对于缩小打包后的代码体积起到了一定的作用，在开发的过程中可以根据实际情况去使用const枚举，同时这样对打包后的代码也可以起到一个更好的加密效果。</p>\n<h3 id=\"1-1-4-对象枚举\"><a href=\"#1-1-4-对象枚举\" class=\"headerlink\" title=\"1.1.4 对象枚举\"></a>1.1.4 对象枚举</h3><p>在没有ts的时候写js代码，我们对枚举的定义都会使用一个对象写出一个枚举</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./enmus.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">StatusEnum</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">off</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StatusEnum</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./enums&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle</span> = (<span class=\"params\">status</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"title class_\">StatusEnum</span>.<span class=\"property\">off</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>在ts项目中，这样的方式去定义枚举也不是不可以的，但是这时候我们可以去设置一个as const只读属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./enmus.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">StatusEnum</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">off</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n\n<p>对象枚举的优点：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将旧的js代码改造成ts更加的方便</span><br><span class=\"line\">可以对键值加计算逻辑</span><br><span class=\"line\">枚举值可以是Symbol类型</span><br><span class=\"line\"></span><br><span class=\"line\">对象枚举的缺点</span><br><span class=\"line\">无法反向映射</span><br><span class=\"line\">对于枚举值的类型描述困难，透传的时候不好去描述类型（可以自己写一个ValueOf工具类型，但是有理解成本，如下代码）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">NoYes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取值</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">ValueOf</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123;[K <span class=\"keyword\">in</span> keyof T]: infer V &#125; ? V : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle1</span> = (<span class=\"params\">k: keyof <span class=\"keyword\">typeof</span> NoYes</span>) =&gt; &#123; <span class=\"comment\">// 通过keyof typeof约束类型，但是不好去透传</span></span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handle2 = （<span class=\"attr\">v</span>: <span class=\"title class_\">ValueOf</span>&lt;<span class=\"keyword\">typeof</span> <span class=\"title class_\">NoYes</span>&gt;) =&gt; &#123; <span class=\"comment\">// 可以透传枚举值，但是ValueOf有理解成本</span></span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-类型守卫\"><a href=\"#1-2-类型守卫\" class=\"headerlink\" title=\"1.2 类型守卫\"></a>1.2 类型守卫</h2><h3 id=\"1-2-1-类型的层级\"><a href=\"#1-2-1-类型的层级\" class=\"headerlink\" title=\"1.2.1 类型的层级\"></a>1.2.1 类型的层级</h3><p>在前面提到了顶级类型的概念，在ts中，类型是有自己的层级的，当一个类型可以被一个类型约束时，那么这个这两个类型便构成了上下级的关系（这节我们就排除any，它是一个特殊的例子）。类型也只能在同级和下级到上级传递，他们也构成了一个单向的传递关系。这也就是任何类型都可以给unknown，never可以给任何类型的原因。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1 | T2 | <span class=\"literal\">undefined</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj3</span>: <span class=\"variable constant_\">T3</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj1); <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj2); <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj3); <span class=\"comment\">// ok!!</span></span><br></pre></td></tr></table></figure>\n\n<p>不过值得注意的是，在非基础类型内部，上下级的关系就是不一样的了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\">arg: T2</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"string\">&#x27;aa&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(obj1)； <span class=\"comment\">// ok！！</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，在开发过程中难免会遇到类型不小心被放大的情况，然后被ts提示有不严谨的地方。(这种时候可能又会有人骂骂咧咧的说ts不好了)<br>在这个是时候其实需要对类型做一个守卫，从而再将类型进行收窄。</p>\n<h3 id=\"1-2-2-类型收窄\"><a href=\"#1-2-2-类型收窄\" class=\"headerlink\" title=\"1.2.2 类型收窄\"></a>1.2.2 类型收窄</h3><p>说起类型收窄，我们首先可以想到的在js中所拥有的</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型判断：typeof；</span><br><span class=\"line\">实例判断：instanceof；</span><br><span class=\"line\">属性判断：in；</span><br><span class=\"line\">字面量相等判断：==，===，!=，!==；</span><br></pre></td></tr></table></figure>\n\n<p>它们在代码书写的时候都将通过if else和switch起到一定的类型守卫的作用，ts也可以对所参与的变量起到一个类型收窄的作用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\">arg?: T1 | T2 | <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!arg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// arg is T1 | T2 | string</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> arg === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// arg is string</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// arg is T1 | T2</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;c&#x27;</span> <span class=\"keyword\">in</span> arg) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arg.<span class=\"property\">d</span> === <span class=\"string\">&#x27;type1&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arg.<span class=\"property\">d</span> === <span class=\"string\">&#x27;type2&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// arg is T2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在后面的章节中会讲到，never是所有类型的子类型，所以说never是所有类型的下级类型。<br>所以说我们可以这么理解</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span></span><br></pre></td></tr></table></figure>\n\n<p>每一个已知类型都是会被ts联合一个never的子类型的，当然这个联合不是我们自己写上去的。<br>所以说我们在使用if，switch做类型收窄的时候就会发现，当我们吧所有的已知类型都考虑完之后，编辑器就会出现一个never未知类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span> | <span class=\"string\">&#x27;b&#x27;</span> | <span class=\"string\">&#x27;c&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// any other keys;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(arg.<span class=\"property\">a</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>: </span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span> </span><br><span class=\"line\">            <span class=\"comment\">// arg.a is never</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过我们上面对never以及上下子类型的理解，知道了T1类型是会被ts给完整的写成</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span> | <span class=\"string\">&#x27;b&#x27;</span> | <span class=\"string\">&#x27;c&#x27;</span> ｜ <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"comment\">// any other keys;</span></span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在开发中我们可以用if else和switch将类型收窄，也可能会想到通过类型断言将类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span>  <span class=\"title function_\">foo1</span> = (<span class=\"params\"> arg: T1 | T2 </span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">t1</span>: <span class=\"variable constant_\">T1</span> | <span class=\"variable constant_\">T2</span> | <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"comment\">// do something...</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1) <span class=\"comment\">// error!！ T1 | T2 | string | undefined类型不能给T1 | T2</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span>) <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T2</span>) <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span> | <span class=\"variable constant_\">T2</span>) <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n<p>这种情况下很大的可能是一些个人原因没定义好类型，在更多的情况下我们遇到的是一个可能为空的情况，于是我们也可以使用非空断言</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">t</span>: <span class=\"variable constant_\">T1</span> <span class=\"comment\">// t is T1 | undefined</span></span><br><span class=\"line\"><span class=\"comment\">// do something...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(t) <span class=\"comment\">// error! t的值很有可能为undefined。</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(t!) <span class=\"comment\">// ok! 通过非空断言（!）断言t不是undefined和null</span></span><br></pre></td></tr></table></figure>\n\n<p>不管怎样，断言收窄还是不建议乱去使用的，更加推荐的是使用is去做一个类型收窄</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> projectType = &lt;T&gt;(</span><br><span class=\"line\">    <span class=\"attr\">data</span>: unknown,</span><br><span class=\"line\">    <span class=\"attr\">cb</span>: <span class=\"function\">(<span class=\"params\">arg: unknown</span>) =&gt;</span> <span class=\"built_in\">boolean</span></span><br><span class=\"line\">): data is T =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg?: T1 | T2</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!arg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// arg is T1 | T2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (projectType&lt;<span class=\"variable constant_\">T1</span>&gt;(arg, <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> !!(a <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span>)?.<span class=\"property\">a</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用is去做类型守卫，看似麻烦了很多。但是从逻辑层面去对数据进行了一个类型收窄，相比于断言，这样可以很大的降低运行时的风险。（当然那个判定逻辑不能随便去写）</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型守卫的核心是将类型收窄，可以将类型收窄成它的子类型</span><br><span class=\"line\">可以灵活的使用js中的相关内容对一个类型做相应的收窄</span><br><span class=\"line\">断言只能在上下级类型断言！不可以在没有上下级关系的类型之间断言，相关的区别会在本文中的断言中做详细介绍。</span><br><span class=\"line\">断言属于欺骗编译器的行为，并不会在运行过程中起作用，在开发中不可以盲目断言！更推荐于使用if else加is去做一个逻辑层的类型守卫。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-any、unknown、never\"><a href=\"#1-3-any、unknown、never\" class=\"headerlink\" title=\"1.3 any、unknown、never\"></a>1.3 any、unknown、never</h2><h3 id=\"1-3-1-any、unknown、never对比\"><a href=\"#1-3-1-any、unknown、never对比\" class=\"headerlink\" title=\"1.3.1 any、unknown、never对比\"></a>1.3.1 any、unknown、never对比</h3><p>ts作为一个静态语言，与强类型还是有所区别的。强类型是将代码编译成另一种语言的代码的，但是静态语言还是逃脱不了是一个弱类型的本质，有很多时候还是可以逃避的。所以说很多时候我们会看到的是能有any，unknown，never这样的隐式类型。<br>它们的区别如下：<br>any属于顶级、底级类型，所有的类型都可以给any，any类型可以给其他任何类型；<br>unknown属于顶级类型，所有的类型都可以给unknown，但是在unknown调用方法时必须要对unknown做存在的判断；<br>never属于底级类型，它可以给所有已知类型，但是已知类型不可以给never类型；</p>\n<h3 id=\"1-3-2-any是top-type和bottom-type\"><a href=\"#1-3-2-any是top-type和bottom-type\" class=\"headerlink\" title=\"1.3.2 any是top type和bottom type\"></a>1.3.2 any是top type和bottom type</h3><p>写过ts代码的人，对any可能是非常熟悉的一个东西了，毕竟any可以解决很多的问题。<br>在ts的提案中，any属于顶级类型，任何类型都可以赋给它。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handle (<span class=\"attr\">item</span>: <span class=\"built_in\">any</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">str</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;hello world!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isYes = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(str) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(num) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(isYes) <span class=\"comment\">// ok!!</span></span><br></pre></td></tr></table></figure>\n\n<p>同时any也是底级类型，它可以赋给任何类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a1</span>: <span class=\"built_in\">any</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">str</span>: <span class=\"built_in\">string</span> = a1; <span class=\"comment\">// ok!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = a1; <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n\n<p>所以说，any的优点还是挺明显的，但是any肯定不是可以让你类型自由的工具。对于代码中还是要尽量的去写已知类型。</p>\n<h3 id=\"1-3-3-unknown是顶级的类型\"><a href=\"#1-3-3-unknown是顶级的类型\" class=\"headerlink\" title=\"1.3.3 unknown是顶级的类型\"></a>1.3.3 unknown是顶级的类型</h3><p>在其他的很多文章中都说unknown和any很像或者类似，但是这个说法也不是那么准确。<br>unknown在ts的提案中定义为了一个顶级的类型。任何类型都可以赋给unknown，在使用unknown的时候需要将类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: unknown</span>) =&gt; &#123;</span><br><span class=\"line\">    arg.<span class=\"title function_\">push</span>() <span class=\"comment\">// error!!</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> arg === <span class=\"string\">&#x27;array&#x27;</span>) &#123;</span><br><span class=\"line\">        arg.<span class=\"title function_\">push</span>() <span class=\"comment\">// ok</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>try catch 语句中的catch后面的error参数会是unknown，然后有的时候我们会碰到比较难处理的情况，我们这个时候也可以使用断言进行类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is unknown</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((err <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span> )?.<span class=\"property\">message</span> === <span class=\"string\">&#x27;...&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> error = err <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span></span><br><span class=\"line\">    <span class=\"comment\">// error is Error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的收窄方式可能还是太机械性了，重复的代码写的太多，我们也可以使用is关键字对unknown进行类型收窄</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对数据进行类型守卫的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data 守卫的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cb 判断守卫的函数，把能够确定的逻辑写进来，返回true就是确定这个类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 第二个参数返回true为这个类型，否则不是</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> projectType = &lt;T&gt;(</span><br><span class=\"line\">    <span class=\"attr\">data</span>: unknown,</span><br><span class=\"line\">    <span class=\"attr\">cb</span>: <span class=\"function\">(<span class=\"params\">arg: unknown</span>) =&gt;</span> <span class=\"built_in\">boolean</span></span><br><span class=\"line\">): data is T =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is unknown</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(projectType&lt;<span class=\"title class_\">Error</span>&gt;(err, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> !!(e <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span>)?.<span class=\"property\">message</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// err is Error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-4-never是所有类型的子类型\"><a href=\"#1-3-4-never是所有类型的子类型\" class=\"headerlink\" title=\"1.3.4 never是所有类型的子类型\"></a>1.3.4 never是所有类型的子类型</h3><p>由上面的对比可知，never可以是所有类型的子类型，在有已知类型的时候，never就会直接合并入已知类型中，不再有never类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T1</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T2</span>: unknown | <span class=\"built_in\">never</span> <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T3</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span> <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T4</span>: <span class=\"built_in\">never</span> <span class=\"comment\">//never</span></span><br></pre></td></tr></table></figure>\n\n<p>所以说never类型可以表示为一个无法推断出来的类型，这个在很多的工具类型特别是使用infer的类型中可以看到。表示的都是无法推断出想要得到的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否为空类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NonNullable</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span> ? <span class=\"built_in\">never</span> : T;</span><br><span class=\"line\"><span class=\"comment\">// 获取函数参数类型的元数组</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Parameters</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取U中的非T部分</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Exclude</span>&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? <span class=\"built_in\">never</span> : T;</span><br><span class=\"line\"><span class=\"comment\">// 取U中的T部分</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Extract</span>&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此外，never还可以表示的是未知类型，意思为它不属于任何一种类型，这种情况下在switch和if else语句中尤为明显，对这个的处理的也能体现出，逻辑代码是否能够考虑极端情况，对代码的稳定性的提高显得尤为重要。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123; no, yes &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleErr</span> = (<span class=\"params\">e: <span class=\"built_in\">Error</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"><span class=\"keyword\">type</span>: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>: </span><br><span class=\"line\">            <span class=\"comment\">// do something....</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">NoYes</span>.<span class=\"property\">no</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>: </span><br><span class=\"line\">        <span class=\"comment\">/* 这种case的时候就是一个never类型，</span></span><br><span class=\"line\"><span class=\"comment\">         * 这种never类型可以给其他的任何类型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">            <span class=\"title function_\">handleErr</span>(<span class=\"keyword\">type</span>); <span class=\"comment\">// ok!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">介绍到这里，或许大家可以对any，unknown与never有一个了解，在使用的时候也有相应的几点建议：</span><br><span class=\"line\">减少未知类型的出现，少写甚至不写any；</span><br><span class=\"line\">对类型的声明要做到准确，避免隐式类型；</span><br><span class=\"line\">对never类型能够做合理拦截；</span><br><span class=\"line\">对于unknown类型能够做出合理的类型收窄；</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-联合undefined-与可选在实际使用过程中的区别\"><a href=\"#1-4-联合undefined-与可选在实际使用过程中的区别\" class=\"headerlink\" title=\"1.4 联合undefined 与可选在实际使用过程中的区别\"></a>1.4 联合undefined 与可选在实际使用过程中的区别</h2><h3 id=\"1-4-1-对象中键值设置为undefined和没有它的区别\"><a href=\"#1-4-1-对象中键值设置为undefined和没有它的区别\" class=\"headerlink\" title=\"1.4.1 对象中键值设置为undefined和没有它的区别\"></a>1.4.1 对象中键值设置为undefined和没有它的区别</h3><p>由于js的灵活性，也是能够允许对象中的键值为null和undefined。但是设置为undefined的时候最重要的一点是可以被遍历到。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">obj.<span class=\"property\">b</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a, b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.<span class=\"property\">b</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n\n<p>为了表示出对象中的缺别，我们就有了键值联合undefined和可选的区别了</p>\n<h3 id=\"1-4-2-ts类型的undefined联合和可选\"><a href=\"#1-4-2-ts类型的undefined联合和可选\" class=\"headerlink\" title=\"1.4.2 ts类型的undefined联合和可选\"></a>1.4.2 ts类型的undefined联合和可选</h3><p>许多人在写ts的时候很早的时候就会注意到那个可选值，然后有的时候也可会观察到有一些的组件库的类型是{k: string | undefined}类型。甚至还会疑惑为什么不是写 ?: (毕竟 ?: 字符少，写起来方便^_^！！)。<br>这个地方就牵扯到ts类型的一个小细节了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span> ｜ <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    d?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj3</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// error，缺少键值c</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj4</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj5</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"literal\">undefined</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj6</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"string\">&#x27;2&#x27;</span> &#125; <span class=\"comment\">// error, d的类型不对</span></span><br></pre></td></tr></table></figure>\n\n<p>当一个类型的键使用可选声明时，这个键代表的就是可有可无了（有肯定是约定好的类型），但是设置为undefined联合时，这个键就必须得有了。<br>而且在我们将键设置为可选时，我们可以对该键进行delete，依然以上面的obj对象为例</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> obj3.<span class=\"property\">d</span> <span class=\"comment\">// ok！！</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj5.<span class=\"property\">c</span> <span class=\"comment\">// error!!</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开发过程中对非基础类型中的undefined属性定义要合理</span><br><span class=\"line\">为了减少可选类型对维护的时候带来的误解，可以使用| undefined来代替可选</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-object、Object与\"><a href=\"#1-5-object、Object与\" class=\"headerlink\" title=\"1.5 object、Object与{}\"></a>1.5 object、Object与{}</h2><h3 id=\"1-5-1-基本类型\"><a href=\"#1-5-1-基本类型\" class=\"headerlink\" title=\"1.5.1 基本类型\"></a>1.5.1 基本类型</h3><p>在ts中，基本类型包括string、number、boolean、symbol、[]、enum、undefined、null、void、unknown、never、any等。详细可见：<a href=\"https://juejin.cn/post/7006304933813157919\">https://juejin.cn/post/7006304933813157919</a><br>它们构成了ts的基本类型，由ts内部自己定义。</p>\n<h3 id=\"1-5-2-非基本类型\"><a href=\"#1-5-2-非基本类型\" class=\"headerlink\" title=\"1.5.2 非基本类型\"></a>1.5.2 非基本类型</h3><p>除了上述的基本类型外，其他的类型都为非基本类型。ts2.7版本中被提出object类型，表示ts中的非基本类型。在此之前，lib.d.ts中收录了Object类型来表示非基本类型。<br>所以说，类似于以下类型，都称为非基本类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T1 &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> T2 &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时在ts的lib.d.ts中，我们也是可以看到有Object的声明的</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Provides functionality common to all JavaScript objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"title class_\">Object</span>: <span class=\"title class_\">ObjectConstructor</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">new</span>(value?: <span class=\"built_in\">any</span>): <span class=\"title class_\">Object</span>;</span><br><span class=\"line\">    (): <span class=\"built_in\">any</span>;</span><br><span class=\"line\">    (<span class=\"attr\">value</span>: <span class=\"built_in\">any</span>): <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** A reference to the prototype for a class of objects. */</span></span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">prototype</span>: <span class=\"title class_\">Object</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>object相当于就是将Object定义成一个基本类型。<br>object与Object的各有以下特点：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object是ts内部定义的基本类型，表示的是非基本类型，不可被重写；</span><br><span class=\"line\">Object类型为lib.d.ts中声明的非基本类型，可以被改写</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-3-Object是所有的非基本类型的父类型\"><a href=\"#1-5-3-Object是所有的非基本类型的父类型\" class=\"headerlink\" title=\"1.5.3 Object是所有的非基本类型的父类型\"></a>1.5.3 Object是所有的非基本类型的父类型</h3><p>所有的非基本类型中，都会继承Object类型。这个也是ts自身赋予的，不需要我们去写。我们在使用一个非基本类型的时候，是可以使用到hasOwnProperty、valueOf、length等原型属性的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T1 &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;a&#x27;</span>); <span class=\"comment\">//ok! Object上有这个方法</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object是基本类型，它表示非基本类型Object</span><br><span class=\"line\">不建议将变量类型直接声明为object或Object，除非真的只用object的原型属性</span><br><span class=\"line\">ObjectConstructor有一些方法类型定义不够准确，可以尝试去改写它</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-interface-和-type-自定义类型\"><a href=\"#1-6-interface-和-type-自定义类型\" class=\"headerlink\" title=\"1.6 interface 和 type  自定义类型\"></a>1.6 interface 和 type  自定义类型</h2><p>大家使用 typescript 总会使用到 interface 和 type,但是很少能够真正区分它俩，接下来介绍下他们之间的区别<br>1、相同点</p>\n<ul>\n<li>都可以描述一个对象或者函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interface定义对象</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interface定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SetUser</span> &#123;</span><br><span class=\"line\">  (<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type定义对象</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SetUser</span> = <span class=\"function\">(<span class=\"params\">name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">number</span></span>)=&gt;</span> <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>都允许拓展（extends）<br>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。<br>interface使用extends、implements组合类型 , type则可以通过&amp;, |符号组合、合并类型。<br>1 interface extends interface</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>type extends type</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Name</span> &amp; &#123; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>  &#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>interface extends type</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>type extends interface</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Name</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、不同点</p>\n<ul>\n<li>type 可以声明基本类型别名，联合类型，元组等类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 联合类型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">wong</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">miao</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Pet</span> = <span class=\"title class_\">Dog</span> | <span class=\"title class_\">Cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体定义数组每个位置的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">PetList</span> = [<span class=\"title class_\">Dog</span>, <span class=\"title class_\">Pet</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"keyword\">type</span> 语句中还可以使用 <span class=\"keyword\">typeof</span> 获取实例的 类型进行赋值</span><br><span class=\"line\"><span class=\"comment\">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> foo <span class=\"comment\">//&#123; a: string, b: 2, c: boolean &#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>interface 能够声明合并，也是interface 一个比较强大的地方，可以重复定义添加属性，type不行</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> </span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123; <span class=\"attr\">sex</span>: <span class=\"built_in\">string</span> &#125; </span><br><span class=\"line\"><span class=\"comment\">/* User 接口为 &#123; name: string age: number sex: string &#125; */</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-amp-交叉类型\"><a href=\"#1-7-amp-交叉类型\" class=\"headerlink\" title=\"1.7  &amp; 交叉类型\"></a>1.7  &amp; 交叉类型</h2><p>在 TypeScript 中交叉类型是将多个类型合并为⼀个类型。通过 &amp; 运算符可以将现有的多种类型叠加到 ⼀起成为⼀种类型，它包含了所需的所有类型的特性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X = &#123; </span><br><span class=\"line\">   <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = X &amp; &#123; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>; &#125;; <span class=\"comment\">// 定义point的类型：  合并X和y的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">point</span>: <span class=\"title class_\">Point</span> = &#123; </span><br><span class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">1</span>, </span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>同名基础类型属性的合并<br>那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型 ⼜不⼀致，⽐如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> X &#123; </span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Y &#123; </span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">    <span class=\"attr\">e</span>: <span class=\"built_in\">string</span> </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">XY</span> = X &amp; Y; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">YX</span> = Y &amp; X; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">p</span>: <span class=\"variable constant_\">XY</span>; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">q</span>: <span class=\"variable constant_\">YX</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在上⾯的代码中，接⼝ X 和接⼝ Y 都含有⼀个相同的成员 c，但它们的类型不⼀致。对于这种情况，此 时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 string 或 number 类型呢？⽐如下⾯的例⼦：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = &#123; <span class=\"attr\">c</span>: <span class=\"number\">6</span>, <span class=\"attr\">d</span>: <span class=\"string\">&quot;d&quot;</span>, <span class=\"attr\">e</span>: <span class=\"string\">&quot;e&quot;</span> &#125;; <span class=\"comment\">// 接上面的示例</span></span><br><span class=\"line\">q = &#123; <span class=\"attr\">c</span>: <span class=\"string\">&quot;c&quot;</span>, <span class=\"attr\">d</span>: <span class=\"string\">&quot;d&quot;</span>, <span class=\"attr\">e</span>: <span class=\"string\">&quot;e&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>为什么接⼝ X 和接⼝ Y 混⼊后，成员 c 的类型会变成 never 呢？这是因为混⼊后成员 c 的类型为<br>string &amp; number ，即成员 c 的类型既可以是 string 类型⼜可以是 number 类型。很明显这种类型<br>是不存在的，所以混⼊后成员 c 的类型为 never，因避免出现类似情况</p>\n<ul>\n<li>同名⾮基础类型属性的合并</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> D &#123; <span class=\"attr\">d</span>: <span class=\"built_in\">boolean</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> E &#123; <span class=\"attr\">e</span>: <span class=\"built_in\">string</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> F &#123; <span class=\"attr\">f</span>: <span class=\"built_in\">number</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123; <span class=\"attr\">x</span>: D; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> B &#123; <span class=\"attr\">x</span>: E; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123; <span class=\"attr\">x</span>: F; &#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ABC</span> = A &amp; B &amp; C;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">abc</span>: <span class=\"variable constant_\">ABC</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">d</span>: <span class=\"literal\">true</span>, <span class=\"attr\">e</span>: <span class=\"string\">&#x27;semlinker&#x27;</span>, <span class=\"attr\">f</span>: <span class=\"number\">666</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure>\n\n<p>由上图可知，在混⼊多个类型时，若存在相同的成员，且成员类型为⾮基本数据类型，那么是可以成功合并。</p>\n<h2 id=\"1-8-Tuple-类型\"><a href=\"#1-8-Tuple-类型\" class=\"headerlink\" title=\"1.8 Tuple 类型\"></a>1.8 Tuple 类型</h2><p>我们知道数组中元素的数据类型一般都是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</p>\n<ul>\n<li>声明一个元组mytuple，并初始化：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> mytuple = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问元组</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple[<span class=\"number\">0</span>]) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple[<span class=\"number\">1</span>]) <span class=\"comment\">// Runoob</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可选元组<br>元组类型允许在元素类型后缀一个 ? 来说明元素是可选的：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>?，<span class=\"built_in\">boolean</span>?]</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>,ture];</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple1 = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple2 = [<span class=\"number\">10</span>,];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>元组越界<br>可以越界添加元素（不建议），但不可越界访问，有可选元素更不建议使用元组越界，因为可选元素一般都在最后</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>] = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br><span class=\"line\">mytuple.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;hello world&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple) <span class=\"comment\">// [10, &#x27;Runoob&#x27;, &#x27;hello world&#x27; ] </span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(list[<span class=\"number\">2</span>]) <span class=\"comment\">// Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命名元组类型<br>命名元组类型适需要 TypeScript 4.0及以上版本才能使用，它极大的改善了我们的开发体验及效率，先来看一个例子:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Address</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setAddress</span>(<span class=\"params\">...args: Address</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们这样定义函数入参后，在使用函数时，编辑器的智能提示只会提示我们参数类型，丢失了对参数含义的描述。</p>\n<p>为了改善这一点，我们可以通过命名元组类型，我们可以这样定义参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Address</span> = [<span class=\"attr\">streetName</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">streetNumber</span>: <span class=\"built_in\">number</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setAddress</span>(<span class=\"params\">...args: Address</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，在调用函数时，我们的参数就获得了相应的语义，这使得代码更加容易维护。<br>这两种⽅式看起来没有多⼤的区别，但对于第⼀种⽅式，我们没法设置第⼀个参数和第⼆个参数的名称。虽然这样对类型检查没有影响，但在元组位置上缺少标签，会使得它们难于使⽤。为了提⾼开发者使⽤元组的体验，TypeScript 4.0 ⽀持为元组类型设置标签</p>\n<ul>\n<li>典型应用 useState</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> [loading, setLoading] = useState&lt;<span class=\"built_in\">boolean</span>&gt;(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-字符串模板类型\"><a href=\"#1-9-字符串模板类型\" class=\"headerlink\" title=\"1.9 字符串模板类型\"></a>1.9 字符串模板类型</h2><h3 id=\"1-9-1-基础语法\"><a href=\"#1-9-1-基础语法\" class=\"headerlink\" title=\"1.9.1  基础语法\"></a>1.9.1  基础语法</h3><p>它的语法和 es 里的字符串模板很相似，所以上手成本也很低，先看几个🌰：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EventName</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span>Changed`</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">EventName</span>&lt;<span class=\"string\">&#x27;foo&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;fooChanged&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">EventName</span>&lt;<span class=\"string\">&#x27;foo&#x27;</span> | <span class=\"string\">&#x27;bar&#x27;</span> | <span class=\"string\">&#x27;baz&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;fooChanged&#x27; | &#x27;barChanged&#x27; | &#x27;bazChanged&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Concat</span>&lt;<span class=\"variable constant_\">S1</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, <span class=\"variable constant_\">S2</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"string\">`<span class=\"subst\">$&#123;S1&#125;</span><span class=\"subst\">$&#123;S2&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Concat</span>&lt;<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;World&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">字符串模板中的联合类型会被展开后排列组合：</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"string\">&#x27;top&#x27;</span> | <span class=\"string\">&#x27;bottom&#x27;</span>&#125;</span>-<span class=\"subst\">$&#123;<span class=\"string\">&#x27;left&#x27;</span> | <span class=\"string\">&#x27;right&#x27;</span>&#125;</span>`</span>;  </span><br><span class=\"line\"><span class=\"comment\">// &#x27;top-left&#x27; | &#x27;top-right&#x27; | &#x27;bottom-left&#x27; | &#x27;bottom-right&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-2-新增关键字\"><a href=\"#1-9-2-新增关键字\" class=\"headerlink\" title=\"1.9.2  新增关键字\"></a>1.9.2  新增关键字</h3><p>为了字符串模板类型这个功能， TS 中新增了四个关键字，用于对模板字符串变量进行处理</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span>  uppercase — 大写字母</span><br><span class=\"line\"><span class=\"bullet\">-</span> lowercase — 小写字母</span><br><span class=\"line\"><span class=\"bullet\">-</span> capitalize — 首字母大写 </span><br><span class=\"line\"><span class=\"bullet\">-</span> uncapitalize — 首字母小写 </span><br><span class=\"line\">type Cases<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">T</span> <span class=\"attr\">extends</span> <span class=\"attr\">string</span>&gt;</span></span> = <span class=\"code\">`$&#123;uppercase T&#125; $&#123;lowercase T&#125; $&#123;capitalize T&#125; $&#123;uncapitalize T&#125;`</span>;</span><br><span class=\"line\">type T11 = Cases&lt;&#x27;bar&#x27;&gt;;  // &#x27;BAR bar Bar bar&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-3-实现类似于正则匹配提取的功能\"><a href=\"#1-9-3-实现类似于正则匹配提取的功能\" class=\"headerlink\" title=\"1.9.3  实现类似于正则匹配提取的功能\"></a>1.9.3  实现类似于正则匹配提取的功能</h3><p>配合infer</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MatchPair</span>&lt;S <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = S <span class=\"keyword\">extends</span> <span class=\"string\">`[<span class=\"subst\">$&#123;infer A&#125;</span>,<span class=\"subst\">$&#123;infer B&#125;</span>]`</span> ? [A, B] : unknown;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T20</span> = <span class=\"title class_\">MatchPair</span>&lt;<span class=\"string\">&#x27;[1,2]&#x27;</span>&gt;;  <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T21</span> = <span class=\"title class_\">MatchPair</span>&lt;<span class=\"string\">&#x27;[foo,bar]&#x27;</span>&gt;;  <span class=\"comment\">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>通过 , 分割左右两边，再在左右两边分别用一个 infer 泛型接受推断值 [${infer A},${infer B}]，就可以轻松的重新组合 , 两边的字符串。</p>\n<h3 id=\"1-9-4-实现-Join-方法\"><a href=\"#1-9-4-实现-Join-方法\" class=\"headerlink\" title=\"1.9.4 实现 Join 方法\"></a>1.9.4 实现 Join 方法</h3><p>… 拓展运算符和 infer</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Join</span>&lt;T <span class=\"keyword\">extends</span> (<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span> | bigint)[], D <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; =</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [] ? <span class=\"string\">&#x27;&#x27;</span> :</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [unknown] ? <span class=\"string\">`<span class=\"subst\">$&#123;T[<span class=\"number\">0</span>]&#125;</span>`</span> :</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [unknown, ...infer U] ? <span class=\"string\">`<span class=\"subst\">$&#123;T[<span class=\"number\">0</span>]&#125;</span><span class=\"subst\">$&#123;D&#125;</span><span class=\"subst\">$&#123;Join&lt;U, D&gt;&#125;</span>`</span> :</span><br><span class=\"line\">    <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T30</span> = <span class=\"title class_\">Join</span>&lt;[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;.&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;1.2.3.4&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T31</span> = <span class=\"title class_\">Join</span>&lt;[<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>, <span class=\"string\">&#x27;baz&#x27;</span>], <span class=\"string\">&#x27;-&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;foo-bar-baz&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-5-实战运用\"><a href=\"#1-9-5-实战运用\" class=\"headerlink\" title=\"1.9.5 实战运用\"></a>1.9.5 实战运用</h3><ul>\n<li>实现 lodash get 函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">PropType</span>&lt;T, <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"built_in\">string</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Path</span> ? unknown :</span><br><span class=\"line\">    <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> keyof T ? T[<span class=\"title class_\">Path</span>] :</span><br><span class=\"line\">    <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> <span class=\"string\">`<span class=\"subst\">$&#123;infer K&#125;</span>.<span class=\"subst\">$&#123;infer R&#125;</span>`</span> ? K <span class=\"keyword\">extends</span> keyof T ? <span class=\"title class_\">PropType</span>&lt;T[K], R&gt; : unknown :</span><br><span class=\"line\">    unknown;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> get&lt;T, P <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">obj</span>: T, <span class=\"attr\">path</span>: P): <span class=\"title class_\">PropType</span>&lt;T, P&gt;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: &#123;<span class=\"attr\">c</span>: <span class=\"number\">42</span>, <span class=\"attr\">d</span>: <span class=\"string\">&#x27;hello&#x27;</span> &#125;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> value = <span class=\"title function_\">get</span>(obj, <span class=\"string\">&quot;a.b.c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2、TypeScript-4-1-带来的这个新功能让-TS-支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获\"><a href=\"#2、TypeScript-4-1-带来的这个新功能让-TS-支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获\" class=\"headerlink\" title=\"2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~\"></a>2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~</h1><h2 id=\"2-1-断言\"><a href=\"#2-1-断言\" class=\"headerlink\" title=\"2.1 断言\"></a>2.1 断言</h2><h3 id=\"2-1-1-非空断言\"><a href=\"#2-1-1-非空断言\" class=\"headerlink\" title=\"2.1.1  非空断言\"></a>2.1.1  非空断言</h3><ul>\n<li>忽略 undefined 和 null 类型<br>问题引入：如何在类型定义时忽略 undefined 和 null 类型？</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString;   <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答：使用非空断言解决：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString!; <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上示例可以看出，非空断言是⼀个后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ null 和⾮ undefined 类型。具体⽽⾔，x! 将从 x 值域中排除 null 和 undefined 。<br>具体示例如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123; </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString; <span class=\"comment\">// Error </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">ignoreUndefinedAndNull</span>: <span class=\"built_in\">string</span> = maybeString!; <span class=\"comment\">// Ok </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>确定赋值断⾔<br>问题引入：如何解决下面这个问题？ 与非空断言的区别<br>代码遮住</li>\n</ul>\n<p>答：使用确定赋值断⾔解决：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x！: <span class=\"built_in\">number</span>; </span><br><span class=\"line\"><span class=\"title function_\">initialize</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span> * x); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initialize</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    x = <span class=\"number\">10</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 let x!: number; 确定赋值断⾔，TypeScript 编译器就会知道该属性会被明确地赋值。</p>\n<h3 id=\"2-1-2-类型断言\"><a href=\"#2-1-2-类型断言\" class=\"headerlink\" title=\"2.1.2  类型断言\"></a>2.1.2  类型断言</h3><p>类型断言就是告诉ts我知道这个变量的类型是什么，它没有运行时的影响，只是在编译阶段起作用</p>\n<ul>\n<li>类型断言有两种形式。 其一是“尖括号”&lt;&gt;语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">someValue</span>: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">strLength</span>: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一个为as语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">someValue</span>: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">strLength</span>: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p>\n<h2 id=\"2-2-可选链运算符\"><a href=\"#2-2-可选链运算符\" class=\"headerlink\" title=\"2.2   ?.   可选链运算符\"></a>2.2   ?.   可选链运算符</h2><p>可选链的核⼼ ?. 运算符,遇到 null 或 undefined 就可以⽴即停⽌某些表达式的运⾏。<br>🌰  可选的属性访问的例⼦：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val = a?.<span class=\"property\">b</span>;</span><br></pre></td></tr></table></figure>\n\n<p>🌰  可选函数调用的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = obj.<span class=\"property\">customMethod</span>?.();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-空值合并运算符\"><a href=\"#2-3-空值合并运算符\" class=\"headerlink\" title=\"2.3  ??  空值合并运算符\"></a>2.3  ??  空值合并运算符</h2><p>问题引入：对于非空判断是否有更优的写法，如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num;</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">result = ( num !== <span class=\"literal\">null</span> &amp;&amp; num !== <span class=\"literal\">undefined</span> ) ? num : num1 ;</span><br></pre></td></tr></table></figure>\n\n<p>答：使用空值合并运算符 ??  </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num;</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">result = num ?? num1 ; <span class=\"comment\">// result === 1</span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上案例，空值合并运算符就是当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"literal\">null</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// 输出：&quot;default string&quot; </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = <span class=\"number\">0</span> ?? <span class=\"number\">42</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(baz); <span class=\"comment\">// 输出：0</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>  与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤ \n</code></pre>\n<p>|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（’’、NaN 或 0）时。</p>\n<ul>\n<li>与可选链操作符 ?. 搭配使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Customer</span> &#123; </span><br><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">city?: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">customer</span>: <span class=\"title class_\">Customer</span> = &#123; </span><br><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"string\">&quot;Semlinker&quot;</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> customerCity = customer?.<span class=\"property\">city</span> ?? <span class=\"string\">&quot;Unknown city&quot;</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(customerCity); <span class=\"comment\">// 输出：Unknown city</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不能与 &amp;&amp; 或 || 操作符共⽤</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> || <span class=\"literal\">undefined</span> ?? <span class=\"string\">&quot;foo&quot;</span>; <span class=\"comment\">// raises a SyntaxError </span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">undefined</span> ?? <span class=\"string\">&quot;foo&quot;</span>; <span class=\"comment\">// raises a SyntaxError</span></span><br></pre></td></tr></table></figure>\n\n<p> 但当使⽤括号来显式表明优先级时是可⾏的，⽐如：<br> (null || undefined ) ?? “foo”; &#x2F;&#x2F; 返回 “foo”</p>\n<h2 id=\"2-4-可选属性\"><a href=\"#2-4-可选属性\" class=\"headerlink\" title=\"2.4   ?:  可选属性\"></a>2.4   ?:  可选属性</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123; </span><br><span class=\"line\">   <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">   age?: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">lolo</span>: <span class=\"title class_\">Person</span> = &#123; </span><br><span class=\"line\">   <span class=\"attr\">name</span>: <span class=\"string\">&quot;lolo&quot;</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后。</p>\n<h2 id=\"2-5-数字分隔符\"><a href=\"#2-5-数字分隔符\" class=\"headerlink\" title=\"2.5  _  数字分隔符\"></a>2.5  _  数字分隔符</h2><p>⼀个数字字⾯量，你现在可以通过把⼀个下划线作为它们之间的分隔符来分组数字，分隔符不会改变数值字⾯量的值，但逻辑分组使⼈们更容易⼀眼就能读懂数字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inhabitantsOfMunich = <span class=\"number\">1_464_301</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> distanceEarthSunInKm = <span class=\"number\">149_600_000</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> fileSystemPermission = <span class=\"number\">0b111_111_000</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> bytes = <span class=\"number\">0b1111_10101011_11110000_00001101</span>;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础概括\"><a href=\"#基础概括\" class=\"headerlink\" title=\"基础概括\"></a>基础概括</h1><h2 id=\"1-1-枚举\"><a href=\"#1-1-枚举\" class=\"headerlink\" title=\"1.1 枚举\"></a>1.1 枚举</h2><h3 id=\"1-1-1-背景介绍\"><a href=\"#1-1-1-背景介绍\" class=\"headerlink\" title=\"1.1.1 背景介绍\"></a>1.1.1 背景介绍</h3><p>维护别人的代码尤其是一些质量较差的代码时，我们常常会碰到以下这样的代码，这样的状态位在之后的开发中很容易混乱。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle</span> = (<span class=\"params\">status: <span class=\"built_in\">number</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">json =&#123;</span><br><span class=\"line\"> <span class=\"string\">&#x27;name&#x27;</span>:<span class=\"string\">&#x27;zhangsan&#x27;</span></span><br><span class=\"line\"> <span class=\"string\">&#x27;email&#x27;</span>:<span class=\"string\">&#x27;1234567@qq.com&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以说这个时候就需要有一个对象可以来将这些状态为做一个集中管理了。</p>\n<h3 id=\"1-1-2-基础用法\"><a href=\"#1-1-2-基础用法\" class=\"headerlink\" title=\"1.1.2 基础用法\"></a>1.1.2 基础用法</h3><p>ts中的枚举其他的高级语言的枚举不同的是，ts中的枚举成员的值可以是字符串&#x2F;数字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"string\">&#x27;no&#x27;</span>,</span><br><span class=\"line\">    yes = <span class=\"string\">&#x27;yes&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"number\">0</span>,</span><br><span class=\"line\">    yes = <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，在ts的枚举中也可以使用数字的递增来定义枚举成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no, <span class=\"comment\">// 0</span></span><br><span class=\"line\">    yes, <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，在定义数字型枚举作为类型时，便会出现一个松散型的类型检查，它会直接将这个枚举类型当作一个number类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no,</span><br><span class=\"line\">    yes,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">11</span>) <span class=\"comment\">// ok! 这个时候是不会报错的</span></span><br></pre></td></tr></table></figure>\n\n<p>因为这个特性，很容易的引起别人对公共模块乱传参对情况，比如说例子中我们无法对函数foo的入参做一个严格的检查。<br>但是当枚举值是字符串时就不再有这个问题了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no = <span class=\"string\">&#x27;no&#x27;</span>,</span><br><span class=\"line\">    yes = <span class=\"string\">&#x27;yes&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something。。。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;no&#x27;</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"title class_\">NoYes</span>.<span class=\"property\">no</span>) <span class=\"comment\">// ok!</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>所以说，在很多的情况下都是建议采用字符串作为枚举值的，可以起到一个更好的约束作用。<br>但是在涉及到与后端的交互的时候，也是没办法的，是数字就还是得用数字，如果说擅自将数字改成字符串的还是会引起一些不必要的麻烦的。遗憾的是，之后的ts版本，将不会再去更新会影响代码运行的内容，所以说对于数字枚举松散型的问题，在后期也是不会再去解决了。<br>于是，我们也可以采用这种方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">    no, <span class=\"comment\">// 0</span></span><br><span class=\"line\">    yes, <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">sig: keyof <span class=\"keyword\">typeof</span> NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something。。。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">11</span>) <span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"string\">&#x27;no&#x27;</span>) <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n\n<p>相比于枚举类型的数字，字符串还是比较好理解的，同时对入参的格式限制也还是有比较准确的定义，可以很好的检查出存不存在乱传参的行为。</p>\n<p>1.1.3 运行时的枚举<br>上文说到枚举是少数的会参与代码运行的ts的内容之一，因此枚举是会被编译成js代码的。<br>以简单的NoYes枚举为例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ts将这个枚举编译为：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">NoYes</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">NoYes</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>[<span class=\"string\">&quot;No&quot;</span>] = <span class=\"number\">0</span>] = <span class=\"string\">&quot;No&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>[<span class=\"string\">&quot;Yes&quot;</span>] = <span class=\"number\">1</span>] = <span class=\"string\">&quot;Yes&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">NoYes</span> || (<span class=\"title class_\">NoYes</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>通过编译后的代码我们可以看出，枚举具有反向映射的功能，可以通过值反向获取到枚举成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>] <span class=\"comment\">// yes</span></span><br></pre></td></tr></table></figure>\n\n<p>为了减小代码运行时的负担，也有了一个常量枚举，让枚举只是参与开发过程，而不在参与js的运行过程。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的NoYes枚举在编译之后是会与类型一样被删除的，而在使用也会有区别。const枚举会失去反向映射的功能</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val1 = <span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span> <span class=\"comment\">// ok! val1 = 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> val2 = <span class=\"title class_\">NoYes</span>[<span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>] <span class=\"comment\">// error!  val2 = undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>编译完之后的代码也会去掉enum的定义，引用的也直接给一个定值</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val2 = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样对于缩小打包后的代码体积起到了一定的作用，在开发的过程中可以根据实际情况去使用const枚举，同时这样对打包后的代码也可以起到一个更好的加密效果。</p>\n<h3 id=\"1-1-4-对象枚举\"><a href=\"#1-1-4-对象枚举\" class=\"headerlink\" title=\"1.1.4 对象枚举\"></a>1.1.4 对象枚举</h3><p>在没有ts的时候写js代码，我们对枚举的定义都会使用一个对象写出一个枚举</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./enmus.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">StatusEnum</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">off</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StatusEnum</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./enums&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle</span> = (<span class=\"params\">status</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status === <span class=\"title class_\">StatusEnum</span>.<span class=\"property\">off</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>在ts项目中，这样的方式去定义枚举也不是不可以的，但是这时候我们可以去设置一个as const只读属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./enmus.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">StatusEnum</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">off</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">on</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n\n<p>对象枚举的优点：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将旧的js代码改造成ts更加的方便</span><br><span class=\"line\">可以对键值加计算逻辑</span><br><span class=\"line\">枚举值可以是Symbol类型</span><br><span class=\"line\"></span><br><span class=\"line\">对象枚举的缺点</span><br><span class=\"line\">无法反向映射</span><br><span class=\"line\">对于枚举值的类型描述困难，透传的时候不好去描述类型（可以自己写一个ValueOf工具类型，但是有理解成本，如下代码）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">NoYes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取值</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> <span class=\"title class_\">ValueOf</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123;[K <span class=\"keyword\">in</span> keyof T]: infer V &#125; ? V : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handle1</span> = (<span class=\"params\">k: keyof <span class=\"keyword\">typeof</span> NoYes</span>) =&gt; &#123; <span class=\"comment\">// 通过keyof typeof约束类型，但是不好去透传</span></span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handle2 = （<span class=\"attr\">v</span>: <span class=\"title class_\">ValueOf</span>&lt;<span class=\"keyword\">typeof</span> <span class=\"title class_\">NoYes</span>&gt;) =&gt; &#123; <span class=\"comment\">// 可以透传枚举值，但是ValueOf有理解成本</span></span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-类型守卫\"><a href=\"#1-2-类型守卫\" class=\"headerlink\" title=\"1.2 类型守卫\"></a>1.2 类型守卫</h2><h3 id=\"1-2-1-类型的层级\"><a href=\"#1-2-1-类型的层级\" class=\"headerlink\" title=\"1.2.1 类型的层级\"></a>1.2.1 类型的层级</h3><p>在前面提到了顶级类型的概念，在ts中，类型是有自己的层级的，当一个类型可以被一个类型约束时，那么这个这两个类型便构成了上下级的关系（这节我们就排除any，它是一个特殊的例子）。类型也只能在同级和下级到上级传递，他们也构成了一个单向的传递关系。这也就是任何类型都可以给unknown，never可以给任何类型的原因。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1 | T2 | <span class=\"literal\">undefined</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\"><span class=\"comment\">//..</span></span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj3</span>: <span class=\"variable constant_\">T3</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj1); <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj2); <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(obj3); <span class=\"comment\">// ok!!</span></span><br></pre></td></tr></table></figure>\n\n<p>不过值得注意的是，在非基础类型内部，上下级的关系就是不一样的了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\">arg: T2</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"string\">&#x27;aa&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(obj1)； <span class=\"comment\">// ok！！</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，在开发过程中难免会遇到类型不小心被放大的情况，然后被ts提示有不严谨的地方。(这种时候可能又会有人骂骂咧咧的说ts不好了)<br>在这个是时候其实需要对类型做一个守卫，从而再将类型进行收窄。</p>\n<h3 id=\"1-2-2-类型收窄\"><a href=\"#1-2-2-类型收窄\" class=\"headerlink\" title=\"1.2.2 类型收窄\"></a>1.2.2 类型收窄</h3><p>说起类型收窄，我们首先可以想到的在js中所拥有的</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型判断：typeof；</span><br><span class=\"line\">实例判断：instanceof；</span><br><span class=\"line\">属性判断：in；</span><br><span class=\"line\">字面量相等判断：==，===，!=，!==；</span><br></pre></td></tr></table></figure>\n\n<p>它们在代码书写的时候都将通过if else和switch起到一定的类型守卫的作用，ts也可以对所参与的变量起到一个类型收窄的作用。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\">arg?: T1 | T2 | <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!arg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">// arg is T1 | T2 | string</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> arg === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// arg is string</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// arg is T1 | T2</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;c&#x27;</span> <span class=\"keyword\">in</span> arg) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arg.<span class=\"property\">d</span> === <span class=\"string\">&#x27;type1&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arg.<span class=\"property\">d</span> === <span class=\"string\">&#x27;type2&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// arg is T2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在后面的章节中会讲到，never是所有类型的子类型，所以说never是所有类型的下级类型。<br>所以说我们可以这么理解</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">never</span>;</span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span></span><br></pre></td></tr></table></figure>\n\n<p>每一个已知类型都是会被ts联合一个never的子类型的，当然这个联合不是我们自己写上去的。<br>所以说我们在使用if，switch做类型收窄的时候就会发现，当我们吧所有的已知类型都考虑完之后，编辑器就会出现一个never未知类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span> | <span class=\"string\">&#x27;b&#x27;</span> | <span class=\"string\">&#x27;c&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// any other keys;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(arg.<span class=\"property\">a</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>: </span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span> </span><br><span class=\"line\">            <span class=\"comment\">// arg.a is never</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过我们上面对never以及上下子类型的理解，知道了T1类型是会被ts给完整的写成</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span> | <span class=\"string\">&#x27;b&#x27;</span> | <span class=\"string\">&#x27;c&#x27;</span> ｜ <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    <span class=\"comment\">// any other keys;</span></span><br><span class=\"line\">&#125; | <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在开发中我们可以用if else和switch将类型收窄，也可能会想到通过类型断言将类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span>  <span class=\"title function_\">foo1</span> = (<span class=\"params\"> arg: T1 | T2 </span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">t1</span>: <span class=\"variable constant_\">T1</span> | <span class=\"variable constant_\">T2</span> | <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"comment\">// do something...</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1) <span class=\"comment\">// error!！ T1 | T2 | string | undefined类型不能给T1 | T2</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span>) <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T2</span>) <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"title function_\">foo1</span>(t1 <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span> | <span class=\"variable constant_\">T2</span>) <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n<p>这种情况下很大的可能是一些个人原因没定义好类型，在更多的情况下我们遇到的是一个可能为空的情况，于是我们也可以使用非空断言</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">t</span>: <span class=\"variable constant_\">T1</span> <span class=\"comment\">// t is T1 | undefined</span></span><br><span class=\"line\"><span class=\"comment\">// do something...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: T1</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(t) <span class=\"comment\">// error! t的值很有可能为undefined。</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(t!) <span class=\"comment\">// ok! 通过非空断言（!）断言t不是undefined和null</span></span><br></pre></td></tr></table></figure>\n\n<p>不管怎样，断言收窄还是不建议乱去使用的，更加推荐的是使用is去做一个类型收窄</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> projectType = &lt;T&gt;(</span><br><span class=\"line\">    <span class=\"attr\">data</span>: unknown,</span><br><span class=\"line\">    <span class=\"attr\">cb</span>: <span class=\"function\">(<span class=\"params\">arg: unknown</span>) =&gt;</span> <span class=\"built_in\">boolean</span></span><br><span class=\"line\">): data is T =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg?: T1 | T2</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!arg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// arg is T1 | T2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (projectType&lt;<span class=\"variable constant_\">T1</span>&gt;(arg, <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> !!(a <span class=\"keyword\">as</span> <span class=\"variable constant_\">T1</span>)?.<span class=\"property\">a</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// arg is T2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用is去做类型守卫，看似麻烦了很多。但是从逻辑层面去对数据进行了一个类型收窄，相比于断言，这样可以很大的降低运行时的风险。（当然那个判定逻辑不能随便去写）</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型守卫的核心是将类型收窄，可以将类型收窄成它的子类型</span><br><span class=\"line\">可以灵活的使用js中的相关内容对一个类型做相应的收窄</span><br><span class=\"line\">断言只能在上下级类型断言！不可以在没有上下级关系的类型之间断言，相关的区别会在本文中的断言中做详细介绍。</span><br><span class=\"line\">断言属于欺骗编译器的行为，并不会在运行过程中起作用，在开发中不可以盲目断言！更推荐于使用if else加is去做一个逻辑层的类型守卫。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-any、unknown、never\"><a href=\"#1-3-any、unknown、never\" class=\"headerlink\" title=\"1.3 any、unknown、never\"></a>1.3 any、unknown、never</h2><h3 id=\"1-3-1-any、unknown、never对比\"><a href=\"#1-3-1-any、unknown、never对比\" class=\"headerlink\" title=\"1.3.1 any、unknown、never对比\"></a>1.3.1 any、unknown、never对比</h3><p>ts作为一个静态语言，与强类型还是有所区别的。强类型是将代码编译成另一种语言的代码的，但是静态语言还是逃脱不了是一个弱类型的本质，有很多时候还是可以逃避的。所以说很多时候我们会看到的是能有any，unknown，never这样的隐式类型。<br>它们的区别如下：<br>any属于顶级、底级类型，所有的类型都可以给any，any类型可以给其他任何类型；<br>unknown属于顶级类型，所有的类型都可以给unknown，但是在unknown调用方法时必须要对unknown做存在的判断；<br>never属于底级类型，它可以给所有已知类型，但是已知类型不可以给never类型；</p>\n<h3 id=\"1-3-2-any是top-type和bottom-type\"><a href=\"#1-3-2-any是top-type和bottom-type\" class=\"headerlink\" title=\"1.3.2 any是top type和bottom type\"></a>1.3.2 any是top type和bottom type</h3><p>写过ts代码的人，对any可能是非常熟悉的一个东西了，毕竟any可以解决很多的问题。<br>在ts的提案中，any属于顶级类型，任何类型都可以赋给它。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handle (<span class=\"attr\">item</span>: <span class=\"built_in\">any</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">str</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;hello world!&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isYes = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(str) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(num) <span class=\"comment\">// ok!!</span></span><br><span class=\"line\"><span class=\"title function_\">handle</span>(isYes) <span class=\"comment\">// ok!!</span></span><br></pre></td></tr></table></figure>\n\n<p>同时any也是底级类型，它可以赋给任何类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a1</span>: <span class=\"built_in\">any</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">str</span>: <span class=\"built_in\">string</span> = a1; <span class=\"comment\">// ok!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> = a1; <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n\n<p>所以说，any的优点还是挺明显的，但是any肯定不是可以让你类型自由的工具。对于代码中还是要尽量的去写已知类型。</p>\n<h3 id=\"1-3-3-unknown是顶级的类型\"><a href=\"#1-3-3-unknown是顶级的类型\" class=\"headerlink\" title=\"1.3.3 unknown是顶级的类型\"></a>1.3.3 unknown是顶级的类型</h3><p>在其他的很多文章中都说unknown和any很像或者类似，但是这个说法也不是那么准确。<br>unknown在ts的提案中定义为了一个顶级的类型。任何类型都可以赋给unknown，在使用unknown的时候需要将类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\">arg: unknown</span>) =&gt; &#123;</span><br><span class=\"line\">    arg.<span class=\"title function_\">push</span>() <span class=\"comment\">// error!!</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> arg === <span class=\"string\">&#x27;array&#x27;</span>) &#123;</span><br><span class=\"line\">        arg.<span class=\"title function_\">push</span>() <span class=\"comment\">// ok</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>try catch 语句中的catch后面的error参数会是unknown，然后有的时候我们会碰到比较难处理的情况，我们这个时候也可以使用断言进行类型收窄。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is unknown</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((err <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span> )?.<span class=\"property\">message</span> === <span class=\"string\">&#x27;...&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> error = err <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span></span><br><span class=\"line\">    <span class=\"comment\">// error is Error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的收窄方式可能还是太机械性了，重复的代码写的太多，我们也可以使用is关键字对unknown进行类型收窄</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对数据进行类型守卫的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data 守卫的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cb 判断守卫的函数，把能够确定的逻辑写进来，返回true就是确定这个类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 第二个参数返回true为这个类型，否则不是</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> projectType = &lt;T&gt;(</span><br><span class=\"line\">    <span class=\"attr\">data</span>: unknown,</span><br><span class=\"line\">    <span class=\"attr\">cb</span>: <span class=\"function\">(<span class=\"params\">arg: unknown</span>) =&gt;</span> <span class=\"built_in\">boolean</span></span><br><span class=\"line\">): data is T =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">cb</span>(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is unknown</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(projectType&lt;<span class=\"title class_\">Error</span>&gt;(err, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> !!(e <span class=\"keyword\">as</span> <span class=\"title class_\">Error</span>)?.<span class=\"property\">message</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// err is Error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-4-never是所有类型的子类型\"><a href=\"#1-3-4-never是所有类型的子类型\" class=\"headerlink\" title=\"1.3.4 never是所有类型的子类型\"></a>1.3.4 never是所有类型的子类型</h3><p>由上面的对比可知，never可以是所有类型的子类型，在有已知类型的时候，never就会直接合并入已知类型中，不再有never类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T1</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T2</span>: unknown | <span class=\"built_in\">never</span> <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T3</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">never</span> <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">T4</span>: <span class=\"built_in\">never</span> <span class=\"comment\">//never</span></span><br></pre></td></tr></table></figure>\n\n<p>所以说never类型可以表示为一个无法推断出来的类型，这个在很多的工具类型特别是使用infer的类型中可以看到。表示的都是无法推断出想要得到的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否为空类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NonNullable</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span> ? <span class=\"built_in\">never</span> : T;</span><br><span class=\"line\"><span class=\"comment\">// 获取函数参数类型的元数组</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Parameters</span>&lt;T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: infer P) =&gt; <span class=\"built_in\">any</span> ? P : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取U中的非T部分</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Exclude</span>&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? <span class=\"built_in\">never</span> : T;</span><br><span class=\"line\"><span class=\"comment\">// 取U中的T部分</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Extract</span>&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此外，never还可以表示的是未知类型，意思为它不属于任何一种类型，这种情况下在switch和if else语句中尤为明显，对这个的处理的也能体现出，逻辑代码是否能够考虑极端情况，对代码的稳定性的提高显得尤为重要。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> <span class=\"title class_\">NoYes</span> &#123; no, yes &#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleErr</span> = (<span class=\"params\">e: <span class=\"built_in\">Error</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"><span class=\"keyword\">type</span>: NoYes</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">NoYes</span>.<span class=\"property\">yes</span>: </span><br><span class=\"line\">            <span class=\"comment\">// do something....</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">NoYes</span>.<span class=\"property\">no</span>:</span><br><span class=\"line\">            <span class=\"comment\">// do something...</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>: </span><br><span class=\"line\">        <span class=\"comment\">/* 这种case的时候就是一个never类型，</span></span><br><span class=\"line\"><span class=\"comment\">         * 这种never类型可以给其他的任何类型</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">            <span class=\"title function_\">handleErr</span>(<span class=\"keyword\">type</span>); <span class=\"comment\">// ok!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">介绍到这里，或许大家可以对any，unknown与never有一个了解，在使用的时候也有相应的几点建议：</span><br><span class=\"line\">减少未知类型的出现，少写甚至不写any；</span><br><span class=\"line\">对类型的声明要做到准确，避免隐式类型；</span><br><span class=\"line\">对never类型能够做合理拦截；</span><br><span class=\"line\">对于unknown类型能够做出合理的类型收窄；</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-联合undefined-与可选在实际使用过程中的区别\"><a href=\"#1-4-联合undefined-与可选在实际使用过程中的区别\" class=\"headerlink\" title=\"1.4 联合undefined 与可选在实际使用过程中的区别\"></a>1.4 联合undefined 与可选在实际使用过程中的区别</h2><h3 id=\"1-4-1-对象中键值设置为undefined和没有它的区别\"><a href=\"#1-4-1-对象中键值设置为undefined和没有它的区别\" class=\"headerlink\" title=\"1.4.1 对象中键值设置为undefined和没有它的区别\"></a>1.4.1 对象中键值设置为undefined和没有它的区别</h3><p>由于js的灵活性，也是能够允许对象中的键值为null和undefined。但是设置为undefined的时候最重要的一点是可以被遍历到。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">obj.<span class=\"property\">b</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a, b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.<span class=\"property\">b</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n\n<p>为了表示出对象中的缺别，我们就有了键值联合undefined和可选的区别了</p>\n<h3 id=\"1-4-2-ts类型的undefined联合和可选\"><a href=\"#1-4-2-ts类型的undefined联合和可选\" class=\"headerlink\" title=\"1.4.2 ts类型的undefined联合和可选\"></a>1.4.2 ts类型的undefined联合和可选</h3><p>许多人在写ts的时候很早的时候就会注意到那个可选值，然后有的时候也可会观察到有一些的组件库的类型是{k: string | undefined}类型。甚至还会疑惑为什么不是写 ?: (毕竟 ?: 字符少，写起来方便^_^！！)。<br>这个地方就牵扯到ts类型的一个小细节了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span> ｜ <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    d?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj1</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj3</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// error，缺少键值c</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj4</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">d</span>: <span class=\"number\">2</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj5</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"literal\">undefined</span> &#125; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj6</span>: <span class=\"variable constant_\">T1</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"attr\">c</span>: <span class=\"literal\">true</span>, <span class=\"attr\">d</span>: <span class=\"string\">&#x27;2&#x27;</span> &#125; <span class=\"comment\">// error, d的类型不对</span></span><br></pre></td></tr></table></figure>\n\n<p>当一个类型的键使用可选声明时，这个键代表的就是可有可无了（有肯定是约定好的类型），但是设置为undefined联合时，这个键就必须得有了。<br>而且在我们将键设置为可选时，我们可以对该键进行delete，依然以上面的obj对象为例</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> obj3.<span class=\"property\">d</span> <span class=\"comment\">// ok！！</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj5.<span class=\"property\">c</span> <span class=\"comment\">// error!!</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开发过程中对非基础类型中的undefined属性定义要合理</span><br><span class=\"line\">为了减少可选类型对维护的时候带来的误解，可以使用| undefined来代替可选</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-5-object、Object与\"><a href=\"#1-5-object、Object与\" class=\"headerlink\" title=\"1.5 object、Object与{}\"></a>1.5 object、Object与{}</h2><h3 id=\"1-5-1-基本类型\"><a href=\"#1-5-1-基本类型\" class=\"headerlink\" title=\"1.5.1 基本类型\"></a>1.5.1 基本类型</h3><p>在ts中，基本类型包括string、number、boolean、symbol、[]、enum、undefined、null、void、unknown、never、any等。详细可见：<a href=\"https://juejin.cn/post/7006304933813157919\">https://juejin.cn/post/7006304933813157919</a><br>它们构成了ts的基本类型，由ts内部自己定义。</p>\n<h3 id=\"1-5-2-非基本类型\"><a href=\"#1-5-2-非基本类型\" class=\"headerlink\" title=\"1.5.2 非基本类型\"></a>1.5.2 非基本类型</h3><p>除了上述的基本类型外，其他的类型都为非基本类型。ts2.7版本中被提出object类型，表示ts中的非基本类型。在此之前，lib.d.ts中收录了Object类型来表示非基本类型。<br>所以说，类似于以下类型，都称为非基本类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T1 &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">c</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> T2 &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">d</span>: <span class=\"string\">&#x27;type2&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时在ts的lib.d.ts中，我们也是可以看到有Object的声明的</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Provides functionality common to all JavaScript objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"title class_\">Object</span>: <span class=\"title class_\">ObjectConstructor</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectConstructor</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">new</span>(value?: <span class=\"built_in\">any</span>): <span class=\"title class_\">Object</span>;</span><br><span class=\"line\">    (): <span class=\"built_in\">any</span>;</span><br><span class=\"line\">    (<span class=\"attr\">value</span>: <span class=\"built_in\">any</span>): <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** A reference to the prototype for a class of objects. */</span></span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">prototype</span>: <span class=\"title class_\">Object</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>object相当于就是将Object定义成一个基本类型。<br>object与Object的各有以下特点：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object是ts内部定义的基本类型，表示的是非基本类型，不可被重写；</span><br><span class=\"line\">Object类型为lib.d.ts中声明的非基本类型，可以被改写</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-3-Object是所有的非基本类型的父类型\"><a href=\"#1-5-3-Object是所有的非基本类型的父类型\" class=\"headerlink\" title=\"1.5.3 Object是所有的非基本类型的父类型\"></a>1.5.3 Object是所有的非基本类型的父类型</h3><p>所有的非基本类型中，都会继承Object类型。这个也是ts自身赋予的，不需要我们去写。我们在使用一个非基本类型的时候，是可以使用到hasOwnProperty、valueOf、length等原型属性的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> T1 &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"variable constant_\">T1</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;a&#x27;</span>); <span class=\"comment\">//ok! Object上有这个方法</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object是基本类型，它表示非基本类型Object</span><br><span class=\"line\">不建议将变量类型直接声明为object或Object，除非真的只用object的原型属性</span><br><span class=\"line\">ObjectConstructor有一些方法类型定义不够准确，可以尝试去改写它</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-interface-和-type-自定义类型\"><a href=\"#1-6-interface-和-type-自定义类型\" class=\"headerlink\" title=\"1.6 interface 和 type  自定义类型\"></a>1.6 interface 和 type  自定义类型</h2><p>大家使用 typescript 总会使用到 interface 和 type,但是很少能够真正区分它俩，接下来介绍下他们之间的区别<br>1、相同点</p>\n<ul>\n<li>都可以描述一个对象或者函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interface定义对象</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interface定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SetUser</span> &#123;</span><br><span class=\"line\">  (<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type定义对象</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type定义函数</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SetUser</span> = <span class=\"function\">(<span class=\"params\">name: <span class=\"built_in\">string</span>, age: <span class=\"built_in\">number</span></span>)=&gt;</span> <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>都允许拓展（extends）<br>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。<br>interface使用extends、implements组合类型 , type则可以通过&amp;, |符号组合、合并类型。<br>1 interface extends interface</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>type extends type</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Name</span> &amp; &#123; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>  &#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>interface extends type</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>type extends interface</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Name</span> &#123; </span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Name</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、不同点</p>\n<ul>\n<li>type 可以声明基本类型别名，联合类型，元组等类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Name</span> = <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 联合类型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">wong</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">miao</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Pet</span> = <span class=\"title class_\">Dog</span> | <span class=\"title class_\">Cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体定义数组每个位置的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">PetList</span> = [<span class=\"title class_\">Dog</span>, <span class=\"title class_\">Pet</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"keyword\">type</span> 语句中还可以使用 <span class=\"keyword\">typeof</span> 获取实例的 类型进行赋值</span><br><span class=\"line\"><span class=\"comment\">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"keyword\">typeof</span> foo <span class=\"comment\">//&#123; a: string, b: 2, c: boolean &#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>interface 能够声明合并，也是interface 一个比较强大的地方，可以重复定义添加属性，type不行</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123; </span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> </span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123; <span class=\"attr\">sex</span>: <span class=\"built_in\">string</span> &#125; </span><br><span class=\"line\"><span class=\"comment\">/* User 接口为 &#123; name: string age: number sex: string &#125; */</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-7-amp-交叉类型\"><a href=\"#1-7-amp-交叉类型\" class=\"headerlink\" title=\"1.7  &amp; 交叉类型\"></a>1.7  &amp; 交叉类型</h2><p>在 TypeScript 中交叉类型是将多个类型合并为⼀个类型。通过 &amp; 运算符可以将现有的多种类型叠加到 ⼀起成为⼀种类型，它包含了所需的所有类型的特性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X = &#123; </span><br><span class=\"line\">   <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = X &amp; &#123; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>; &#125;; <span class=\"comment\">// 定义point的类型：  合并X和y的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">point</span>: <span class=\"title class_\">Point</span> = &#123; </span><br><span class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">1</span>, </span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"number\">1</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>同名基础类型属性的合并<br>那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型 ⼜不⼀致，⽐如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> X &#123; </span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">    <span class=\"attr\">d</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Y &#123; </span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">    <span class=\"attr\">e</span>: <span class=\"built_in\">string</span> </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">XY</span> = X &amp; Y; </span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">YX</span> = Y &amp; X; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">p</span>: <span class=\"variable constant_\">XY</span>; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">q</span>: <span class=\"variable constant_\">YX</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在上⾯的代码中，接⼝ X 和接⼝ Y 都含有⼀个相同的成员 c，但它们的类型不⼀致。对于这种情况，此 时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 string 或 number 类型呢？⽐如下⾯的例⼦：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = &#123; <span class=\"attr\">c</span>: <span class=\"number\">6</span>, <span class=\"attr\">d</span>: <span class=\"string\">&quot;d&quot;</span>, <span class=\"attr\">e</span>: <span class=\"string\">&quot;e&quot;</span> &#125;; <span class=\"comment\">// 接上面的示例</span></span><br><span class=\"line\">q = &#123; <span class=\"attr\">c</span>: <span class=\"string\">&quot;c&quot;</span>, <span class=\"attr\">d</span>: <span class=\"string\">&quot;d&quot;</span>, <span class=\"attr\">e</span>: <span class=\"string\">&quot;e&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>为什么接⼝ X 和接⼝ Y 混⼊后，成员 c 的类型会变成 never 呢？这是因为混⼊后成员 c 的类型为<br>string &amp; number ，即成员 c 的类型既可以是 string 类型⼜可以是 number 类型。很明显这种类型<br>是不存在的，所以混⼊后成员 c 的类型为 never，因避免出现类似情况</p>\n<ul>\n<li>同名⾮基础类型属性的合并</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> D &#123; <span class=\"attr\">d</span>: <span class=\"built_in\">boolean</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> E &#123; <span class=\"attr\">e</span>: <span class=\"built_in\">string</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> F &#123; <span class=\"attr\">f</span>: <span class=\"built_in\">number</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123; <span class=\"attr\">x</span>: D; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> B &#123; <span class=\"attr\">x</span>: E; &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> C &#123; <span class=\"attr\">x</span>: F; &#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ABC</span> = A &amp; B &amp; C;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">abc</span>: <span class=\"variable constant_\">ABC</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">d</span>: <span class=\"literal\">true</span>, <span class=\"attr\">e</span>: <span class=\"string\">&#x27;semlinker&#x27;</span>, <span class=\"attr\">f</span>: <span class=\"number\">666</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure>\n\n<p>由上图可知，在混⼊多个类型时，若存在相同的成员，且成员类型为⾮基本数据类型，那么是可以成功合并。</p>\n<h2 id=\"1-8-Tuple-类型\"><a href=\"#1-8-Tuple-类型\" class=\"headerlink\" title=\"1.8 Tuple 类型\"></a>1.8 Tuple 类型</h2><p>我们知道数组中元素的数据类型一般都是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</p>\n<ul>\n<li>声明一个元组mytuple，并初始化：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> mytuple = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问元组</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple[<span class=\"number\">0</span>]) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple[<span class=\"number\">1</span>]) <span class=\"comment\">// Runoob</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可选元组<br>元组类型允许在元素类型后缀一个 ? 来说明元素是可选的：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>?，<span class=\"built_in\">boolean</span>?]</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>,ture];</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple1 = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> mytuple2 = [<span class=\"number\">10</span>,];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>元组越界<br>可以越界添加元素（不建议），但不可越界访问，有可选元素更不建议使用元组越界，因为可选元素一般都在最后</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">mytuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>] = [<span class=\"number\">10</span>,<span class=\"string\">&quot;Runoob&quot;</span>];</span><br><span class=\"line\">mytuple.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;hello world&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mytuple) <span class=\"comment\">// [10, &#x27;Runoob&#x27;, &#x27;hello world&#x27; ] </span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(list[<span class=\"number\">2</span>]) <span class=\"comment\">// Tuple type &#x27;[string, number]&#x27; of length &#x27;2&#x27; has no element at index &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命名元组类型<br>命名元组类型适需要 TypeScript 4.0及以上版本才能使用，它极大的改善了我们的开发体验及效率，先来看一个例子:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Address</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setAddress</span>(<span class=\"params\">...args: Address</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们这样定义函数入参后，在使用函数时，编辑器的智能提示只会提示我们参数类型，丢失了对参数含义的描述。</p>\n<p>为了改善这一点，我们可以通过命名元组类型，我们可以这样定义参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Address</span> = [<span class=\"attr\">streetName</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">streetNumber</span>: <span class=\"built_in\">number</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setAddress</span>(<span class=\"params\">...args: Address</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，在调用函数时，我们的参数就获得了相应的语义，这使得代码更加容易维护。<br>这两种⽅式看起来没有多⼤的区别，但对于第⼀种⽅式，我们没法设置第⼀个参数和第⼆个参数的名称。虽然这样对类型检查没有影响，但在元组位置上缺少标签，会使得它们难于使⽤。为了提⾼开发者使⽤元组的体验，TypeScript 4.0 ⽀持为元组类型设置标签</p>\n<ul>\n<li>典型应用 useState</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> [loading, setLoading] = useState&lt;<span class=\"built_in\">boolean</span>&gt;(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-9-字符串模板类型\"><a href=\"#1-9-字符串模板类型\" class=\"headerlink\" title=\"1.9 字符串模板类型\"></a>1.9 字符串模板类型</h2><h3 id=\"1-9-1-基础语法\"><a href=\"#1-9-1-基础语法\" class=\"headerlink\" title=\"1.9.1  基础语法\"></a>1.9.1  基础语法</h3><p>它的语法和 es 里的字符串模板很相似，所以上手成本也很低，先看几个🌰：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EventName</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"string\">`<span class=\"subst\">$&#123;T&#125;</span>Changed`</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">EventName</span>&lt;<span class=\"string\">&#x27;foo&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;fooChanged&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">EventName</span>&lt;<span class=\"string\">&#x27;foo&#x27;</span> | <span class=\"string\">&#x27;bar&#x27;</span> | <span class=\"string\">&#x27;baz&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;fooChanged&#x27; | &#x27;barChanged&#x27; | &#x27;bazChanged&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Concat</span>&lt;<span class=\"variable constant_\">S1</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, <span class=\"variable constant_\">S2</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"string\">`<span class=\"subst\">$&#123;S1&#125;</span><span class=\"subst\">$&#123;S2&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Concat</span>&lt;<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;World&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">字符串模板中的联合类型会被展开后排列组合：</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"string\">&#x27;top&#x27;</span> | <span class=\"string\">&#x27;bottom&#x27;</span>&#125;</span>-<span class=\"subst\">$&#123;<span class=\"string\">&#x27;left&#x27;</span> | <span class=\"string\">&#x27;right&#x27;</span>&#125;</span>`</span>;  </span><br><span class=\"line\"><span class=\"comment\">// &#x27;top-left&#x27; | &#x27;top-right&#x27; | &#x27;bottom-left&#x27; | &#x27;bottom-right&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-2-新增关键字\"><a href=\"#1-9-2-新增关键字\" class=\"headerlink\" title=\"1.9.2  新增关键字\"></a>1.9.2  新增关键字</h3><p>为了字符串模板类型这个功能， TS 中新增了四个关键字，用于对模板字符串变量进行处理</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span>  uppercase — 大写字母</span><br><span class=\"line\"><span class=\"bullet\">-</span> lowercase — 小写字母</span><br><span class=\"line\"><span class=\"bullet\">-</span> capitalize — 首字母大写 </span><br><span class=\"line\"><span class=\"bullet\">-</span> uncapitalize — 首字母小写 </span><br><span class=\"line\">type Cases<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">T</span> <span class=\"attr\">extends</span> <span class=\"attr\">string</span>&gt;</span></span> = <span class=\"code\">`$&#123;uppercase T&#125; $&#123;lowercase T&#125; $&#123;capitalize T&#125; $&#123;uncapitalize T&#125;`</span>;</span><br><span class=\"line\">type T11 = Cases&lt;&#x27;bar&#x27;&gt;;  // &#x27;BAR bar Bar bar&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-3-实现类似于正则匹配提取的功能\"><a href=\"#1-9-3-实现类似于正则匹配提取的功能\" class=\"headerlink\" title=\"1.9.3  实现类似于正则匹配提取的功能\"></a>1.9.3  实现类似于正则匹配提取的功能</h3><p>配合infer</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MatchPair</span>&lt;S <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = S <span class=\"keyword\">extends</span> <span class=\"string\">`[<span class=\"subst\">$&#123;infer A&#125;</span>,<span class=\"subst\">$&#123;infer B&#125;</span>]`</span> ? [A, B] : unknown;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T20</span> = <span class=\"title class_\">MatchPair</span>&lt;<span class=\"string\">&#x27;[1,2]&#x27;</span>&gt;;  <span class=\"comment\">// [&#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T21</span> = <span class=\"title class_\">MatchPair</span>&lt;<span class=\"string\">&#x27;[foo,bar]&#x27;</span>&gt;;  <span class=\"comment\">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<p>通过 , 分割左右两边，再在左右两边分别用一个 infer 泛型接受推断值 [${infer A},${infer B}]，就可以轻松的重新组合 , 两边的字符串。</p>\n<h3 id=\"1-9-4-实现-Join-方法\"><a href=\"#1-9-4-实现-Join-方法\" class=\"headerlink\" title=\"1.9.4 实现 Join 方法\"></a>1.9.4 实现 Join 方法</h3><p>… 拓展运算符和 infer</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Join</span>&lt;T <span class=\"keyword\">extends</span> (<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span> | bigint)[], D <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; =</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [] ? <span class=\"string\">&#x27;&#x27;</span> :</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [unknown] ? <span class=\"string\">`<span class=\"subst\">$&#123;T[<span class=\"number\">0</span>]&#125;</span>`</span> :</span><br><span class=\"line\">    T <span class=\"keyword\">extends</span> [unknown, ...infer U] ? <span class=\"string\">`<span class=\"subst\">$&#123;T[<span class=\"number\">0</span>]&#125;</span><span class=\"subst\">$&#123;D&#125;</span><span class=\"subst\">$&#123;Join&lt;U, D&gt;&#125;</span>`</span> :</span><br><span class=\"line\">    <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T30</span> = <span class=\"title class_\">Join</span>&lt;[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;.&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;1.2.3.4&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T31</span> = <span class=\"title class_\">Join</span>&lt;[<span class=\"string\">&#x27;foo&#x27;</span>, <span class=\"string\">&#x27;bar&#x27;</span>, <span class=\"string\">&#x27;baz&#x27;</span>], <span class=\"string\">&#x27;-&#x27;</span>&gt;;  <span class=\"comment\">// &#x27;foo-bar-baz&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-5-实战运用\"><a href=\"#1-9-5-实战运用\" class=\"headerlink\" title=\"1.9.5 实战运用\"></a>1.9.5 实战运用</h3><ul>\n<li>实现 lodash get 函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">PropType</span>&lt;T, <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt; = <span class=\"built_in\">string</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Path</span> ? unknown :</span><br><span class=\"line\">    <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> keyof T ? T[<span class=\"title class_\">Path</span>] :</span><br><span class=\"line\">    <span class=\"title class_\">Path</span> <span class=\"keyword\">extends</span> <span class=\"string\">`<span class=\"subst\">$&#123;infer K&#125;</span>.<span class=\"subst\">$&#123;infer R&#125;</span>`</span> ? K <span class=\"keyword\">extends</span> keyof T ? <span class=\"title class_\">PropType</span>&lt;T[K], R&gt; : unknown :</span><br><span class=\"line\">    unknown;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> get&lt;T, P <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">obj</span>: T, <span class=\"attr\">path</span>: P): <span class=\"title class_\">PropType</span>&lt;T, P&gt;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">b</span>: &#123;<span class=\"attr\">c</span>: <span class=\"number\">42</span>, <span class=\"attr\">d</span>: <span class=\"string\">&#x27;hello&#x27;</span> &#125;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> value = <span class=\"title function_\">get</span>(obj, <span class=\"string\">&quot;a.b.c&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2、TypeScript-4-1-带来的这个新功能让-TS-支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获\"><a href=\"#2、TypeScript-4-1-带来的这个新功能让-TS-支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获\" class=\"headerlink\" title=\"2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~\"></a>2、TypeScript 4.1 带来的这个新功能让 TS 支持更多字符串相关的拼接场景，其实是特别实用的，希望大家能够有所收获~</h1><h2 id=\"2-1-断言\"><a href=\"#2-1-断言\" class=\"headerlink\" title=\"2.1 断言\"></a>2.1 断言</h2><h3 id=\"2-1-1-非空断言\"><a href=\"#2-1-1-非空断言\" class=\"headerlink\" title=\"2.1.1  非空断言\"></a>2.1.1  非空断言</h3><ul>\n<li>忽略 undefined 和 null 类型<br>问题引入：如何在类型定义时忽略 undefined 和 null 类型？</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString;   <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答：使用非空断言解决：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString!; <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上示例可以看出，非空断言是⼀个后缀表达式操作符 ! 可以⽤于断⾔操作对象是⾮ null 和⾮ undefined 类型。具体⽽⾔，x! 将从 x 值域中排除 null 和 undefined 。<br>具体示例如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\">maybeString: <span class=\"built_in\">string</span> | <span class=\"literal\">undefined</span> | <span class=\"literal\">null</span></span>) &#123; </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">onlyString</span>: <span class=\"built_in\">string</span> = maybeString; <span class=\"comment\">// Error </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">ignoreUndefinedAndNull</span>: <span class=\"built_in\">string</span> = maybeString!; <span class=\"comment\">// Ok </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>确定赋值断⾔<br>问题引入：如何解决下面这个问题？ 与非空断言的区别<br>代码遮住</li>\n</ul>\n<p>答：使用确定赋值断⾔解决：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x！: <span class=\"built_in\">number</span>; </span><br><span class=\"line\"><span class=\"title function_\">initialize</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span> * x); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">initialize</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    x = <span class=\"number\">10</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 let x!: number; 确定赋值断⾔，TypeScript 编译器就会知道该属性会被明确地赋值。</p>\n<h3 id=\"2-1-2-类型断言\"><a href=\"#2-1-2-类型断言\" class=\"headerlink\" title=\"2.1.2  类型断言\"></a>2.1.2  类型断言</h3><p>类型断言就是告诉ts我知道这个变量的类型是什么，它没有运行时的影响，只是在编译阶段起作用</p>\n<ul>\n<li>类型断言有两种形式。 其一是“尖括号”&lt;&gt;语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">someValue</span>: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">strLength</span>: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一个为as语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">someValue</span>: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">strLength</span>: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p>\n<h2 id=\"2-2-可选链运算符\"><a href=\"#2-2-可选链运算符\" class=\"headerlink\" title=\"2.2   ?.   可选链运算符\"></a>2.2   ?.   可选链运算符</h2><p>可选链的核⼼ ?. 运算符,遇到 null 或 undefined 就可以⽴即停⽌某些表达式的运⾏。<br>🌰  可选的属性访问的例⼦：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> val = a?.<span class=\"property\">b</span>;</span><br></pre></td></tr></table></figure>\n\n<p>🌰  可选函数调用的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = obj.<span class=\"property\">customMethod</span>?.();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-空值合并运算符\"><a href=\"#2-3-空值合并运算符\" class=\"headerlink\" title=\"2.3  ??  空值合并运算符\"></a>2.3  ??  空值合并运算符</h2><p>问题引入：对于非空判断是否有更优的写法，如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num;</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">result = ( num !== <span class=\"literal\">null</span> &amp;&amp; num !== <span class=\"literal\">undefined</span> ) ? num : num1 ;</span><br></pre></td></tr></table></figure>\n\n<p>答：使用空值合并运算符 ??  </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num;</span><br><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">result = num ?? num1 ; <span class=\"comment\">// result === 1</span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上案例，空值合并运算符就是当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"literal\">null</span> ?? <span class=\"string\">&#x27;default string&#x27;</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// 输出：&quot;default string&quot; </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = <span class=\"number\">0</span> ?? <span class=\"number\">42</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(baz); <span class=\"comment\">// 输出：0</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>  与逻辑或 || 运算符不同，逻辑或会在左操作数为 falsy 值时返回右侧操作数。也就是说，如果你使⽤ \n</code></pre>\n<p>|| 来为某些变量设置默认的值时，你可能会遇到意料之外的⾏为。⽐如为 falsy 值（’’、NaN 或 0）时。</p>\n<ul>\n<li>与可选链操作符 ?. 搭配使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Customer</span> &#123; </span><br><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">city?: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">customer</span>: <span class=\"title class_\">Customer</span> = &#123; </span><br><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"string\">&quot;Semlinker&quot;</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> customerCity = customer?.<span class=\"property\">city</span> ?? <span class=\"string\">&quot;Unknown city&quot;</span>; </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(customerCity); <span class=\"comment\">// 输出：Unknown city</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不能与 &amp;&amp; 或 || 操作符共⽤</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> || <span class=\"literal\">undefined</span> ?? <span class=\"string\">&quot;foo&quot;</span>; <span class=\"comment\">// raises a SyntaxError </span></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"literal\">undefined</span> ?? <span class=\"string\">&quot;foo&quot;</span>; <span class=\"comment\">// raises a SyntaxError</span></span><br></pre></td></tr></table></figure>\n\n<p> 但当使⽤括号来显式表明优先级时是可⾏的，⽐如：<br> (null || undefined ) ?? “foo”; &#x2F;&#x2F; 返回 “foo”</p>\n<h2 id=\"2-4-可选属性\"><a href=\"#2-4-可选属性\" class=\"headerlink\" title=\"2.4   ?:  可选属性\"></a>2.4   ?:  可选属性</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123; </span><br><span class=\"line\">   <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; </span><br><span class=\"line\">   age?: <span class=\"built_in\">number</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">lolo</span>: <span class=\"title class_\">Person</span> = &#123; </span><br><span class=\"line\">   <span class=\"attr\">name</span>: <span class=\"string\">&quot;lolo&quot;</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后。</p>\n<h2 id=\"2-5-数字分隔符\"><a href=\"#2-5-数字分隔符\" class=\"headerlink\" title=\"2.5  _  数字分隔符\"></a>2.5  _  数字分隔符</h2><p>⼀个数字字⾯量，你现在可以通过把⼀个下划线作为它们之间的分隔符来分组数字，分隔符不会改变数值字⾯量的值，但逻辑分组使⼈们更容易⼀眼就能读懂数字</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> inhabitantsOfMunich = <span class=\"number\">1_464_301</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> distanceEarthSunInKm = <span class=\"number\">149_600_000</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> fileSystemPermission = <span class=\"number\">0b111_111_000</span>; </span><br><span class=\"line\"><span class=\"keyword\">const</span> bytes = <span class=\"number\">0b1111_10101011_11110000_00001101</span>;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl0eypmz30000kqfyhn9chvei","tag_id":"cl0eypmz80001kqfy028cd3pi","_id":"cl0eypmz90002kqfy76f1ajdm"},{"post_id":"cl0eypmza0003kqfyh5rg4kc2","tag_id":"cl0eypmzb0004kqfyhhwmcznb","_id":"cl0eypmzb0005kqfy4pw7fyka"}],"Tag":[{"name":"typescript 类型编程","_id":"cl0eypmz80001kqfy028cd3pi"},{"name":"typescript 基础知识","_id":"cl0eypmzb0004kqfyhhwmcznb"}]}}